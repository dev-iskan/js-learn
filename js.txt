открываем <script src='...'> /// </script> если мы добавляем src, то внутри тегов ничего не будет выполняться

обработчики событий также позволяют содавать скрипты:
	<h1 onclick="alert('Hello')">
		Hello
	</h1>

также можно передать на обработку в javascript через тег <a href>:
<a href="JavaScript:alert('другой способ')">js</a>

но в таком виде мы не всегда можем получить что хотим


JavaScript регистрозависимый язык, т.е. правильно надо обозначать все переменные и названия функций

у js есть 2 вида коментариев: строчный и блочный:
// - строчный 
/*      */ -блочный

с помощью var создаем переменную:
var name;
name="iskandar"

неизменяемые типы это логические, числовые, null, булевые, undefined

typeof() метод который показывает тип данных
isNaN() -метод который проверяет если переменная не число то вернет истину
isFinite() - возвращает true если переменная отлична от NaN и бесконечности
конкатинация будет через +: str1 + ' ' + str2;
метод вывода на экран document.write(string);

если мы подключим файл .js в head то вывод document.write будет выходить сразу после тега body
в остальных случаях выводится там же где и он сам

функция Number() переводит что либо в число: Number(null) будет 0
String() наоборот в строку
parseInt()- явное приведение в int, то есть только целую часть: parseInt(10.9) будет 10
parseFloat() - приведение в float

если мы хотим прибавлять строки, то получаем конкатинацию:
'10'+'20' будет 1020
но если умножим то получим '10'*'20' будет 200 и если не получится перевести в числа и умножить то результат будет NaN
если сложим 10+ '20' также будет 1020, т.к. конкатинируются


если например:б
var b=+a;
то b будет уже не строкой а числом

десятичные числа можно также записывать как var a=.2;  и выведется 0.2


методы ввода и вывода:
alert("message") - выводит сообщение и ожидает пока пользователь закроет окно
confirm("message") - предлагает нажимать либо ok либо cancel и возвращает либо истину либо ложь
prompt("message", "default message")- выводит сообщение на экран и ждем ввод произвольной строки и соответственно возвращает данную строку

showModalDialog() - отображает модальное окно в котором можно вводить какой либо текст и позже передать его в скрипт
метод eval() вычисляет числа
инструкция void узнает значение операнда и убирает его, чаще всего применяется в адресах url


массивы - динамические в javascript
var array=[];
var array1=new Array(par1, par2)
var array1=new Array(size)

если мы передадим в document.write(array) - то на экран выведется строка, т.к. массивы это обьекты а у обьектов есть метод toString() который превращает массив в строку

длину массива можно узнать через метод .length: 
var arr=[]
var size=arr.length;

цикл for in применяется для обхода либо массива либо обьекта:
for(var index in array){
	document.write("Индекс массива - "+index);
}

метод join преобразует все элементы массива в строку и разделяет каким нибудь разделителем:
document.write(array.join("-|-")) - значения массива array разделятся такими вот знаками
array.reverse() - переворачивает массив
array.sort() - сортирует по порядку массив
arr.sort([compareFunction]) - если мы предоставим compareFunction то массив будет отсортирован по этой функции:
function compare(a, b) {
  if (a меньше b по некоторому критерию сортировки) {
    return -1;
  }
  if (a больше b по некоторому критерию сортировки) {
    return 1;
  }
  // a должно быть равным b
  return 0;
}

метод arr.concat() - возвращает новый массив с добавленными значениями:
var arr=['a', 'b', 'c'];
var newArr=arr.concat('d', 'e', 'f');
теперь newArr имеет ['a', 'b', 'c', 'd', 'e', 'f'];

метод .slice('начало', 'конец')- выделяет подмассив который будет вырезан из массива:
arr=['a', 'b', 'c', 'd', 'e', 'f'];
var newArr=arr.slice(2,4); - 2 начинается 'c', 4 где заканчивается 'd'
то получим newArr['c', 'd']
если arr.slice(-2, -4)- то slice будет выбирать с конца

метод splice - позволяет и добавлять и удалять исходный массив:
arr.splice('позиция начинания', 'количество элементов которое надо вырезать') - если не передать 2 параметр то удалятся все значения с начинающей позиции

если хотим добавить что либо то:
arr.splice('позиция', 'количество удаления', 'добавка нового значения', ...);
arr.splice(1,0,'c', 'd' ,'e')- то есть после 1 индекса не удаляем ничего а добавляем новые значения c, d, e


arr.push() - добавит в конец массива новые элементы
arr.pop() - удалит с конца массива последний элемент
arr.unshift()- добавит в начало массива новый элемент
arr.shift() - удаляет с начала массива первый элемент

delete arr[index] - удалит значение в индексе, но не удалит саму ячейку, т.е присваиваем в эту ячейку undefined

Array.isArray(arr) - проверит является ли массивом переменная переданная параметром



работа со строками:
т.к. строка это обьект класса String() то мы можем использовать также методы работы с обьектами

str='Искандар'
str[1] // с
то есть как с массивом
но также есть метод str.charAt(1) который также вернет // с

метод concat() - добавит в строку новую часть
str.indexOf('строка')- производит поиск строки которая прописана параметром и возвращает индекс символа с которого начинается строка
str.lastIndexOf('строка') делает то же самое но возвращает последний индекс с которой начинается строка
str.split(',') - разбивает строку по опрделенному разделителю если передать split("") - то он полностью разделит строку на буквы
str.replace('строка которую надо заменить', 'строка на которую надо заменить')- заменяет строку на другую
str.substr('индекс', 'длина')- данный метод возвращает подстроку которая начинается с индекса и с определенной длиной
str.substring('индекс начала', 'индекс конца')- также возвращает подстроку но с начальным и конечным индексом
str.toUpperCase()- переделывает всю строку на прописные буквы
str.toLowerCase() - наоборот в строчные переводит
str.slice()- также вырезает подстроку но отличие от substring в том что slice может принимать отрицательные параметры, которые обозначают выборку с конца: str.slice(-2, -7)- вырезка будет с конца

str.search() - выполняет поиска по шаблону регулярного выражения, если не найдено то возвращает -1
str.match()- также работает как search() возвращает массив совпадений
str.localeCompare(str2)- сравнивает 2 строки. если они полностью идентичны то вернет 0, если менбше то -1, если строка str больше str2 то 1


функции:
если мы хотим передать много параметров в функцию то можно использовать такую конструкцию:
function foo(){
	var array = arguments;
	//код
}
foo(1,2,3,4,5,6,7,8,[1,2,3,4,5,]) - таким образом все параметры попадут в массив arguments;
но если мы не учитываем arguments внутри функции, то все параметры которые не указаны в функции просто будут проигнорированы

вложенные функции имеют доступ к параметром родительской функции


работа с датами:
var now= new Date(); - если вывести на экран то мы увидем время сейчас на английском
now.toLocaleString() - покажет нам время на родном языке
now.toLocaleDateString() - мы увидим только дату
now.toLocaleTimeString() - только время
now.getDate() - вернет число без даты: 2 - то есть 2 февраля
now.getMonth() - вернет месяц: 1 - то есть февраль, потому что в javascript месяцы начинаются с 0-январь
now.getDay() - показывает дни недели: 1-понедельник, 2-вторник и т.д.
now.getFullYear() - показывает год: 2018
now.getYear() - возвращает год от которого вычитается число 1900: т.е. 118
now.getTime() -  вернет количество миллисекунд от 1 января 1970 года
now.getHours() - текущий час
now.getMinutes() - вернет минуты количество минут
now.getSeconds() - вернет количество секунд
now.getMilliseconds()- количество миллисекунд

если те же методы но с приставкой UTC - то получим время по гринвичу
getUTCHours()  и т.д.

можем ввести свой собственный год:
now.setFullYear(1990) - год 1990
now.setMonth(9) - октябрь
now.setDate(25)- то 25 число
день недели нельзя задать
now.setHours()- назначаем часы, если мы поставим число больше чем 24, то JS автоматически поменяет на следующий день и время в остатке
now.setMinutes() - также если превысим минуты то добавит в часы
now.setMilliseconds() - установка миллисекунд
now.setTime() - задаем миллисекунды от 1 января 1970 года

в конструктор Date() можем задать параметры:
var newDate = new Date(2018, 1, 3, 17, 38, 41) - будет 2018 февраля 3 число 17.38.41 - время


таймеры:
setTimeout('метод', периодн времени)- через определенное время будет вызвана функция добавленная в 1 параметр



DOM:
document.getElementById('id'); - получить весь элемент по id, помимо самого элемента мы также получаем доступ к его html коду, типу и количеству дочерних элементов
document.getElementsByTagName('tag') - получаем элемент по тэгу: p, h1, div и т.д. чаще всего вернется массив


var mainTitle=document.getElementById('mainTitle');

alert("This is an element of type : " + mainTitle.nodeType); - тут мы получис номер типа: 1-element, 2-attribute, 3-tag
alert("This inner HTML is : " + mainTitle.innerHTML);- вернет HTML код внутри данной id
alert("Child nodes : " + mainTitle.childNodes.length)- вернет количество дочерних элементов

интересен момент того что .getElementsById можно вызвать не только по Document части DOM, но и по обьектам, пример:
var myList=document.getElementById("listFirst"); - мы принимаем обьект с id = listFirst
var myLiList=myList.getElementsByTagName("li");- а тут мы получаем список обьектов по тэгу ли, но не во всем документе а только у myList


работа с атрибутами:
var myElement= document.getElementById("id1");

myElement.getAttribute("align")- получаем атрибут
myElement.setAttribute("align", "left")- то есть мы настраиваем атрибут и придаем ему значение

создание элементов:
var myElement = documen.getElementsByTagName("ul") - допустим у нас есть элемент с тэгом ul, myElement нас самом деле массив
var myNewElement=document.createElement("li") - создание нового элемента
myNewElement.innerHTML= "Some text"
myElement.appendChild(myNewElement) - мы добавляем в массив myElement новый элемент

или же можно углубленно создать новый элемент, точнее элементы
var myText=document.createTextNode("New li item in text")
myNewElement.appendChild(myText)

алтернативный способ:
parent.insertBefore(newElement, existingElement) - добавляем элемент в документ, но в этом случае мы добавим новый элемент перед существующим
var myNewElement=document.createElement("li")
var existingElement= myElement.getElementsByTagName("li")[1] -  то есть получимв массив с li тэгами и выберем именно вторую ячейку
myElements.insertBefore(myNewElement, existngElement) - добавим перед второй ячейкой


Event Handling:
все события начинаются с on: onClick, onLoad, onScroll и т.д.
но мы должны прописать слушателей событий, т.е. функции которые будут выполняться при определенном событии
1) прописывать слушателя прямо рядом с событием:
onClick="alert('Hello, World!)"
2) создаем элемент и для него прописываем код по событию
var element = document.getElementById("id")
element.onClick=function(){
	//Handler
};
3)пишем метод для элемента, в этом случае огромное преимущество то что для одного события можно создать несколько слушателей:
document/event.addEventListener('click', myFunction, false); - создает слушателя
document/event.removeEventListener('click', myFunction, false); - удаляет слушателя

если мы хотим допустим вызывать alert при нажатии на картинку, то:
var myImage=document.getElementById("mainImage");
myImage.onclick=function(){
	alert("You clicked on image!");
};

если мы вызываем скрипты в документеЮ но доступ дан им в тэгэ head, то пропишем такую логику:

sript.js:
	function prepareEventHandlers(){
	   var myImage=document.getElementById("mainImage");
		myImage.onclick=function(){
		alert("You clicked on image!");
		};
	}

	windows.onload=function(){
		prepareEventHandlers();
	};
суть в том что функция onload будет запускать js код сразу во время загрузки

onFocus и onBlur события, позволяют выполнять опр логику если элемент под фокусом или наоборот оставлен
var emailField=document.getElementById("email");

emailField.onfocus=function(){
	if(emailField.value="your email"){
	emailField="";
	}
};

emailField.onblur=function(){
	if(emailField.value=""){
	emailField="your email";
	}
};

Таймеры:
function simpleMessage(){
	alert('This is just message');
}

есть 2 способа для таймеров- setTimeout() один раз, setInterval() повторяющийся
setTimeout(simpleMessage, 5000) - через 5 секунд мы получим alert()
setInterval(simpleMessage, 5000) - каждые 5 секунд будет появляться alert()

var intervalHandle = setInterval(simpleMessage, 5000)
document.getElementById('image').onclick = function(){
	clearInterval(intervalHandle); 
};
setInterval может возвращать значения а именно какой интервал происходи, и таким образом мы можем остановить таймер



Ошибки:
частые проблемы - 
синтаксические ошибки,
вызов прописными буквами,
использование DOM перед тем как сам документ вызван,



Формы:
получить любое поле формы можно либо через getElementById или document.forms.(имя_name)
textfield: 
	есть значение: textField.value
	можно назначить события: onfocus, onblur, onchange, onkeypress, onkeydown, onkeyup
radio:
	radio.checked
	события: onclick, onchange
select:
	select.type (select-one or select-moltiple)
	select.selectIndex  - можно узнать какой выбор сделан
	select.options[x].selected - для нескольких выборов
	события: onchange

форма:
	события : onsubmit - при нажатии submit если вернем false в обработчике событий, то можно отменить submit


Работа со стилями:
inline свойства можно изменять через подфункцию .style:
element.style.[стиль в css] - element.style.color='#fffff'
одно но, в css стили прописываются через -: font-weight или background-color: в javascript: fontWeight или colorBackground

также можно изменять целые div через стилизирования классов, например:
myElement.className - именно classNmae, т.к. .class нельзя использовать в js




унарные опаерторы: +-*/%, если данные операторы буду выставлены перед строкой, то они попытаются преобразовать строку, и выполнить свою операцию:
если поставить -'5', то сначала '5' превратится в число 5, а потом он станет отрицательняым числом.

если разделить 0/0 то получим NaN, также если попытаемся умножить или разделить строку на число то также получим NaN


в JS + также работает как оператор конкатинации строк, '2'+'3'='23'
при любых случаях если выполняется сложение строки и числа, то + будет работать как оператор конкат. '2' + 3 = '23'

но другие операторы работают как должны '2' - 1 = 1


равентство == и опертор идентичности === сравнивают по особенному:

'10' == 10, т.к при == сначала правая часть переведется в число и потом произойдет сравнение,
'10'=== 10 вернет false,
NaN никогда не равно ничему


при сравнении строк < > исчисляют не количество символов, а по значению символа в ANSI:
'Hello' < 'h' , т.к. h в ANSI больше чем H


анонимные функции:

var func = function(param1, param2){
	///
	///
}  - таким образом мы можетм вызвать определенную функцию через имя переменной

если мы хотим сразу же вызвать функцию при обьявлении, то делаем так:


var func = (function(par1, par2){
	///
	///
} (par1=555, par2 =333));  - то есть обрамляем скобками функцию, и если что то нужно передать то после самой функции мы передаем их


если в функцию мы передаем больше переменных, чем обьявлено изначально, то мы обращаемся к обьекту arguments, при этом это индексный массив:

function func(param1, param2){
	
	arguments;

	return param1+param2+arguments[2];
}


func(1,2,3,4,5,6,7,8,0)


методы для работы с массивами:
.. in array, метод in просматривает определенный атрибут в массиве, (3 in arr2) если действительно 3 есть то in вернет true

Array.isArray(массив)- вернет true, если проверяемый массив является действительно массивом

arr.join(разделитель) - превращает все атрибуты массива в строку обьединяет их и возвращает строку.  arr.join('-') - соединит все элменты массива через -


arr.reverse()- переворачивает все элементы в массиве.


arr.sort(порядок) - возвращает отсортированный массив, если без параметров то сортирует по возрастанию, 

arr.sort(function(a,b){
	return a-b // отсортирует по возрасатанию
	return b-a // отсортирует по убыванию
}) 


arr.concat() - сливает 2 массива или массив с последувотельностью элементов


arr.slice() - возвращает фрагмент или подмассив указаноого массива, параметры a= первый элемент для проверки, b = последний элемент, но не включается
var frag= arr.slice(a, b) если писать с минусом то он будет выбирать с конца

splice() - производит вставку или удаляет элементы массива, возвращает те элементый которые были удалены
arr.splice(a, b, c,d,e,f,...) - a= обьявляет первый элемент с какого надо считать, b= количество удаляемых элементов, если не передавать 2 параметр, то splice удалит все элементы начиная с a. следующие элементы после b это те элементый которые будут добавлены в массива


arr.push(элементы) - добавляет в конец массива элементы, и возвращает новую длину массива

arr.pop() - удаляет последний элемент массива, и вовзр. длину массива


arr.unshift(элементы) - добавляет элементы в начало массива

arr.shif() - удаляет первый элемент и возвращает его, все элементы смещаются в индексе

delete arrp4 - удаляет элемент массива,



arr.forEach(function(value, index, a){
	
});

arr.map(function(value, index, a){
	
	return value * value;

}); - работает так же  как foreach, но функция внутри возвращает новый массив.


arr.filter(function(value, index, a){
	
	return value<5;

}); - возвращает массив содержащий опр количество элементов исходного массива, работает также как foreach но функция должна возвращать истину что элемент вошел в новый массив


arr.every(function(value, index, a){
	
	return x<5;

})- возвращает истину, если передаваемая функция возвр истину для всех элементов массива


arr.every(function(value, index, a){
	
	return x<5;

}) - возвращает истину, если хотя бы один элемент истина


arr.reduce(function(x,y){

return x+y;

}, 0) - используется для обьединения массива, используя функцию



arr.indexOf(value) - возвращает индекс от, начала массива к концу и ищет то самое значение
arr.lastIndexOf(value)- в обратном порядке


for(var key in arr){
	document.write(key+ ' => '+arr[key]+'<br>'+);
}