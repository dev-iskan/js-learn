открываем <script src='...'> /// </script> если мы добавляем src, то внутри тегов ничего не будет выполняться

обработчики событий также позволяют содавать скрипты:
	<h1 onclick="alert('Hello')">
		Hello
	</h1>

также можно передать на обработку в javascript через тег <a href>:
<a href="JavaScript:alert('другой способ')">js</a>

но в таком виде мы не всегда можем получить что хотим


JavaScript регистрозависимый язык, т.е. правильно надо обозначать все переменные и названия функций

у js есть 2 вида коментариев: строчный и блочный:
// - строчный 
/*      */ -блочный

с помощью var создаем переменную:
var name;
name="iskandar"

неизменяемые типы это логические, числовые, null, булевые, undefined

typeof() метод который показывает тип данных
isNaN() -метод который проверяет если переменная не число то вернет истину
isFinite() - возвращает true если переменная отлична от NaN и бесконечности
конкатинация будет через +: str1 + ' ' + str2;
метод вывода на экран document.write(string);

если мы подключим файл .js в head то вывод document.write будет выходить сразу после тега body
в остальных случаях выводится там же где и он сам

функция Number() переводит что либо в число: Number(null) будет 0
String() наоборот в строку
parseInt()- явное приведение в int, то есть только целую часть: parseInt(10.9) будет 10
parseFloat() - приведение в float

если мы хотим прибавлять строки, то получаем конкатинацию:
'10'+'20' будет 1020
но если умножим то получим '10'*'20' будет 200 и если не получится перевести в числа и умножить то результат будет NaN
если сложим 10+ '20' также будет 1020, т.к. конкатинируются


если например:б
var b=+a;
то b будет уже не строкой а числом

десятичные числа можно также записывать как var a=.2;  и выведется 0.2


методы ввода и вывода:
alert("message") - выводит сообщение и ожидает пока пользователь закроет окно
confirm("message") - предлагает нажимать либо ok либо cancel и возвращает либо истину либо ложь
prompt("message", "default message")- выводит сообщение на экран и ждем ввод произвольной строки и соответственно возвращает данную строку

showModalDialog() - отображает модальное окно в котором можно вводить какой либо текст и позже передать его в скрипт
метод eval() вычисляет числа
инструкция void узнает значение операнда и убирает его, чаще всего применяется в адресах url


массивы - динамические в javascript
var array=[];
var array1=new Array(par1, par2)
var array1=new Array(size)

если мы передадим в document.write(array) - то на экран выведется строка, т.к. массивы это обьекты а у обьектов есть метод toString() который превращает массив в строку

длину массива можно узнать через метод .length: 
var arr=[]
var size=arr.length;

цикл for in применяется для обхода либо массива либо обьекта:
for(var index in array){
	document.write("Индекс массива - "+index);
}

метод join преобразует все элементы массива в строку и разделяет каким нибудь разделителем:
document.write(array.join("-|-")) - значения массива array разделятся такими вот знаками
array.reverse() - переворачивает массив
array.sort() - сортирует по порядку массив
arr.sort([compareFunction]) - если мы предоставим compareFunction то массив будет отсортирован по этой функции:
function compare(a, b) {
  if (a меньше b по некоторому критерию сортировки) {
    return -1;
  }
  if (a больше b по некоторому критерию сортировки) {
    return 1;
  }
  // a должно быть равным b
  return 0;
}

метод arr.concat() - возвращает новый массив с добавленными значениями:
var arr=['a', 'b', 'c'];
var newArr=arr.concat('d', 'e', 'f');
теперь newArr имеет ['a', 'b', 'c', 'd', 'e', 'f'];

метод .slice('начало', 'конец')- выделяет подмассив который будет вырезан из массива:
arr=['a', 'b', 'c', 'd', 'e', 'f'];
var newArr=arr.slice(2,4); - 2 начинается 'c', 4 где заканчивается 'd'
то получим newArr['c', 'd']
если arr.slice(-2, -4)- то slice будет выбирать с конца

метод splice - позволяет и добавлять и удалять исходный массив:
arr.splice('позиция начинания', 'количество элементов которое надо вырезать') - если не передать 2 параметр то удалятся все значения с начинающей позиции

если хотим добавить что либо то:
arr.splice('позиция', 'количество удаления', 'добавка нового значения', ...);
arr.splice(1,0,'c', 'd' ,'e')- то есть после 1 индекса не удаляем ничего а добавляем новые значения c, d, e


arr.push() - добавит в конец массива новые элементы
arr.pop() - удалит с конца массива последний элемент
arr.unshift()- добавит в начало массива новый элемент
arr.shift() - удаляет с начала массива первый элемент

delete arr[index] - удалит значение в индексе, но не удалит саму ячейку, т.е присваиваем в эту ячейку undefined

Array.isArray(arr) - проверит является ли массивом переменная переданная параметром



работа со строками:
т.к. строка это обьект класса String() то мы можем использовать также методы работы с обьектами

str='Искандар'
str[1] // с
то есть как с массивом
но также есть метод str.charAt(1) который также вернет // с

метод concat() - добавит в строку новую часть
str.indexOf('строка')- производит поиск строки которая прописана параметром и возвращает индекс символа с которого начинается строка
str.lastIndexOf('строка') делает то же самое но возвращает последний индекс с которой начинается строка
str.split(',') - разбивает строку по опрделенному разделителю если передать split("") - то он полностью разделит строку на буквы
str.replace('строка которую надо заменить', 'строка на которую надо заменить')- заменяет строку на другую
str.substr('индекс', 'длина')- данный метод возвращает подстроку которая начинается с индекса и с определенной длиной
str.substring('индекс начала', 'индекс конца')- также возвращает подстроку но с начальным и конечным индексом
str.toUpperCase()- переделывает всю строку на прописные буквы
str.toLowerCase() - наоборот в строчные переводит
str.slice()- также вырезает подстроку но отличие от substring в том что slice может принимать отрицательные параметры, которые обозначают выборку с конца: str.slice(-2, -7)- вырезка будет с конца

str.search() - выполняет поиска по шаблону регулярного выражения, если не найдено то возвращает -1
str.match()- также работает как search() возвращает массив совпадений
str.localeCompare(str2)- сравнивает 2 строки. если они полностью идентичны то вернет 0, если менбше то -1, если строка str больше str2 то 1


функции:
если мы хотим передать много параметров в функцию то можно использовать такую конструкцию:
function foo(){
	var array = arguments;
	//код
}
foo(1,2,3,4,5,6,7,8,[1,2,3,4,5,]) - таким образом все параметры попадут в массив arguments;
но если мы не учитываем arguments внутри функции, то все параметры которые не указаны в функции просто будут проигнорированы

вложенные функции имеют доступ к параметром родительской функции


работа с датами:
var now= new Date(); - если вывести на экран то мы увидем время сейчас на английском
now.toLocaleString() - покажет нам время на родном языке
now.toLocaleDateString() - мы увидим только дату
now.toLocaleTimeString() - только время
now.getDate() - вернет число без даты: 2 - то есть 2 февраля
now.getMonth() - вернет месяц: 1 - то есть февраль, потому что в javascript месяцы начинаются с 0-январь
now.getDay() - показывает дни недели: 1-понедельник, 2-вторник и т.д.
now.getFullYear() - показывает год: 2018
now.getYear() - возвращает год от которого вычитается число 1900: т.е. 118
now.getTime() -  вернет количество миллисекунд от 1 января 1970 года
now.getHours() - текущий час
now.getMinutes() - вернет минуты количество минут
now.getSeconds() - вернет количество секунд
now.getMilliseconds()- количество миллисекунд

если те же методы но с приставкой UTC - то получим время по гринвичу
getUTCHours()  и т.д.

можем ввести свой собственный год:
now.setFullYear(1990) - год 1990
now.setMonth(9) - октябрь
now.setDate(25)- то 25 число
день недели нельзя задать
now.setHours()- назначаем часы, если мы поставим число больше чем 24, то JS автоматически поменяет на следующий день и время в остатке
now.setMinutes() - также если превысим минуты то добавит в часы
now.setMilliseconds() - установка миллисекунд
now.setTime() - задаем миллисекунды от 1 января 1970 года

в конструктор Date() можем задать параметры:
var newDate = new Date(2018, 1, 3, 17, 38, 41) - будет 2018 февраля 3 число 17.38.41 - время


таймеры:
setTimeout('метод', периодн времени)- через определенное время будет вызвана функция добавленная в 1 параметр



DOM:
document.getElementById('id'); - получить весь элемент по id, помимо самого элемента мы также получаем доступ к его html коду, типу и количеству дочерних элементов
document.getElementsByTagName('tag') - получаем элемент по тэгу: p, h1, div и т.д. чаще всего вернется массив


var mainTitle=document.getElementById('mainTitle');

alert("This is an element of type : " + mainTitle.nodeType); - тут мы получис номер типа: 1-element, 2-attribute, 3-tag
alert("This inner HTML is : " + mainTitle.innerHTML);- вернет HTML код внутри данной id
alert("Child nodes : " + mainTitle.childNodes.length)- вернет количество дочерних элементов

интересен момент того что .getElementsById можно вызвать не только по Document части DOM, но и по обьектам, пример:
var myList=document.getElementById("listFirst"); - мы принимаем обьект с id = listFirst
var myLiList=myList.getElementsByTagName("li");- а тут мы получаем список обьектов по тэгу ли, но не во всем документе а только у myList


работа с атрибутами:
var myElement= document.getElementById("id1");

myElement.getAttribute("align")- получаем атрибут
myElement.setAttribute("align", "left")- то есть мы настраиваем атрибут и придаем ему значение

создание элементов:
var myElement = documen.getElementsByTagName("ul") - допустим у нас есть элемент с тэгом ul, myElement нас самом деле массив
var myNewElement=document.createElement("li") - создание нового элемента
myNewElement.innerHTML= "Some text"
myElement.appendChild(myNewElement) - мы добавляем в массив myElement новый элемент

или же можно углубленно создать новый элемент, точнее элементы
var myText=document.createTextNode("New li item in text")
myNewElement.appendChild(myText)

алтернативный способ:
parent.insertBefore(newElement, existingElement) - добавляем элемент в документ, но в этом случае мы добавим новый элемент перед существующим
var myNewElement=document.createElement("li")
var existingElement= myElement.getElementsByTagName("li")[1] -  то есть получимв массив с li тэгами и выберем именно вторую ячейку
myElements.insertBefore(myNewElement, existngElement) - добавим перед второй ячейкой


Event Handling:
все события начинаются с on: onClick, onLoad, onScroll и т.д.
но мы должны прописать слушателей событий, т.е. функции которые будут выполняться при определенном событии
1) прописывать слушателя прямо рядом с событием:
onClick="alert('Hello, World!)"
2) создаем элемент и для него прописываем код по событию
var element = document.getElementById("id")
element.onClick=function(){
	//Handler
};
3)пишем метод для элемента, в этом случае огромное преимущество то что для одного события можно создать несколько слушателей:
document/event.addEventListener('click', myFunction, false); - создает слушателя
document/event.removeEventListener('click', myFunction, false); - удаляет слушателя

если мы хотим допустим вызывать alert при нажатии на картинку, то:
var myImage=document.getElementById("mainImage");
myImage.onclick=function(){
	alert("You clicked on image!");
};

если мы вызываем скрипты в документеЮ но доступ дан им в тэгэ head, то пропишем такую логику:

sript.js:
	function prepareEventHandlers(){
	   var myImage=document.getElementById("mainImage");
		myImage.onclick=function(){
		alert("You clicked on image!");
		};
	}

	windows.onload=function(){
		prepareEventHandlers();
	};
суть в том что функция onload будет запускать js код сразу во время загрузки

onFocus и onBlur события, позволяют выполнять опр логику если элемент под фокусом или наоборот оставлен
var emailField=document.getElementById("email");

emailField.onfocus=function(){
	if(emailField.value="your email"){
	emailField="";
	}
};

emailField.onblur=function(){
	if(emailField.value=""){
	emailField="your email";
	}
};

Таймеры:
function simpleMessage(){
	alert('This is just message');
}

есть 2 способа для таймеров- setTimeout() один раз, setInterval() повторяющийся
setTimeout(simpleMessage, 5000) - через 5 секунд мы получим alert()
setInterval(simpleMessage, 5000) - каждые 5 секунд будет появляться alert()

var intervalHandle = setInterval(simpleMessage, 5000)
document.getElementById('image').onclick = function(){
	clearInterval(intervalHandle); 
};
setInterval может возвращать значения а именно какой интервал происходи, и таким образом мы можем остановить таймер



Ошибки:
частые проблемы - 
синтаксические ошибки,
вызов прописными буквами,
использование DOM перед тем как сам документ вызван,



Формы:
получить любое поле формы можно либо через getElementById или document.forms.(имя_name)
textfield: 
	есть значение: textField.value
	можно назначить события: onfocus, onblur, onchange, onkeypress, onkeydown, onkeyup
radio:
	radio.checked
	события: onclick, onchange
select:
	select.type (select-one or select-moltiple)
	select.selectIndex  - можно узнать какой выбор сделан
	select.options[x].selected - для нескольких выборов
	события: onchange

форма:
	события : onsubmit - при нажатии submit если вернем false в обработчике событий, то можно отменить submit


Работа со стилями:
inline свойства можно изменять через подфункцию .style:
element.style.[стиль в css] - element.style.color='#fffff'
одно но, в css стили прописываются через -: font-weight или background-color: в javascript: fontWeight или colorBackground

также можно изменять целые div через стилизирования классов, например:
myElement.className - именно classNmae, т.к. .class нельзя использовать в js




унарные опаерторы: +-*/%, если данные операторы буду выставлены перед строкой, то они попытаются преобразовать строку, и выполнить свою операцию:
если поставить -'5', то сначала '5' превратится в число 5, а потом он станет отрицательняым числом.

если разделить 0/0 то получим NaN, также если попытаемся умножить или разделить строку на число то также получим NaN


в JS + также работает как оператор конкатинации строк, '2'+'3'='23'
при любых случаях если выполняется сложение строки и числа, то + будет работать как оператор конкат. '2' + 3 = '23'

но другие операторы работают как должны '2' - 1 = 1


равентство == и опертор идентичности === сравнивают по особенному:

'10' == 10, т.к при == сначала правая часть переведется в число и потом произойдет сравнение,
'10'=== 10 вернет false,
NaN никогда не равно ничему


при сравнении строк < > исчисляют не количество символов, а по значению символа в ANSI:
'Hello' < 'h' , т.к. h в ANSI больше чем H


анонимные функции:

var func = function(param1, param2){
	///
	///
}  - таким образом мы можетм вызвать определенную функцию через имя переменной

если мы хотим сразу же вызвать функцию при обьявлении, то делаем так:


var func = (function(par1, par2){
	///
	///
} (par1=555, par2 =333));  - то есть обрамляем скобками функцию, и если что то нужно передать то после самой функции мы передаем их


если в функцию мы передаем больше переменных, чем обьявлено изначально, то мы обращаемся к обьекту arguments, при этом это индексный массив:

function func(param1, param2){
	
	arguments;

	return param1+param2+arguments[2];
}


func(1,2,3,4,5,6,7,8,0)


методы для работы с массивами:
.. in array, метод in просматривает определенный атрибут в массиве, (3 in arr2) если действительно 3 есть то in вернет true

Array.isArray(массив)- вернет true, если проверяемый массив является действительно массивом

arr.join(разделитель) - превращает все атрибуты массива в строку обьединяет их и возвращает строку.  arr.join('-') - соединит все элменты массива через -


arr.reverse()- переворачивает все элементы в массиве.


arr.sort(порядок) - возвращает отсортированный массив, если без параметров то сортирует по возрастанию, 

arr.sort(function(a,b){
	return a-b // отсортирует по возрасатанию
	return b-a // отсортирует по убыванию
}) 


arr.concat() - сливает 2 массива или массив с последувотельностью элементов


arr.slice() - возвращает фрагмент или подмассив указаноого массива, параметры a= первый элемент для проверки, b = последний элемент, но не включается
var frag= arr.slice(a, b) если писать с минусом то он будет выбирать с конца

splice() - производит вставку или удаляет элементы массива, возвращает те элементый которые были удалены
arr.splice(a, b, c,d,e,f,...) - a= обьявляет первый элемент с какого надо считать, b= количество удаляемых элементов, если не передавать 2 параметр, то splice удалит все элементы начиная с a. следующие элементы после b это те элементый которые будут добавлены в массива


arr.push(элементы) - добавляет в конец массива элементы, и возвращает новую длину массива

arr.pop() - удаляет последний элемент массива, и вовзр. длину массива


arr.unshift(элементы) - добавляет элементы в начало массива

arr.shif() - удаляет первый элемент и возвращает его, все элементы смещаются в индексе

delete arrp4 - удаляет элемент массива,



arr.forEach(function(value, index, a){
	
});

arr.map(function(value, index, a){
	
	return value * value;

}); - работает так же  как foreach, но функция внутри возвращает новый массив.


arr.filter(function(value, index, a){
	
	return value<5;

}); - возвращает массив содержащий опр количество элементов исходного массива, работает также как foreach но функция должна возвращать истину что элемент вошел в новый массив


arr.every(function(value, index, a){
	
	return x<5;

})- возвращает истину, если передаваемая функция возвр истину для всех элементов массива


arr.every(function(value, index, a){
	
	return x<5;

}) - возвращает истину, если хотя бы один элемент истина


arr.reduce(function(x,y){

return x+y;

}, 0) - используется для обьединения массива, используя функцию



arr.indexOf(value) - возвращает индекс от, начала массива к концу и ищет то самое значение
arr.lastIndexOf(value)- в обратном порядке


for(var key in arr){
	document.write(key+ ' => '+arr[key]+'<br>'+);
}




String{
	
	строка это обьект класса String, и к ней мы имеем доступ в виде массива:
	str[10]; или str.charAt(10);

	str.concat('text', 'text2', ...) - метод обьединения строк, принимает параметром строки которые нужно добавить


	str.indexOf('substr', 'position') - метод нахождения подстроки в строке, и возвращает позицию начала подстроки, если не найдены то возвращает -1, также можно передать начальную позицию с которой надо начинать поиск

	str.lasIndexOf('substr', 'postion')- то же самое но с конца

	str.length() - возвращает количество символов

	str.localeCompare('str1') - сравнивает с учетом локализации две строки, str и str1, если str>str1 то вернет 1, если две разные локализации, то вернет -1

   примеры использования:
   strings=['мир', 'привет', 'сравнение', 'что-то изучаем'];

   strings=strings.sort(function (a,b) {

   		return a.localeCompare(b);
   })

   таким образом мы отсортируем массив strings по порядку и длине строк


   str.match(regexp) - возвращает массив результатов поиска, зависит от добавления g в regexp
   str.replace(regexp, 'replacement') - заменяет результаты поиска
   str.search(regexp) - возвращает позицию начала первой подстроки соответствующей regexp, игнорирует флаг g, -1 если не найдет
   str.slice(index, last_index) - возвращает подстроку, где index это начало срезания, last_index это конечный индекс, который не попадает в новую подстроку.
   str.split(delimiter, num_of_elements) - делит строку на массив где delimeter разделитель
   str.substr(index, number) - берет substring с index начала и количеством number
   str.toLocaleLowerCase() - переводит все символы с маленькой буквы
   str.toLocaleUpperCase() - наоборот




}



Обьекты {
	
обьекты создаются: использование литерал обькта {} - заклыченный в эти скобки список свойств

var obj = {
	
};

свойтсва даются через такой способ:

var obj1 = {
	name : "Hello",
	'someName' : "World"
} - тут мы видим что name это имя свойства, далее : и далее само значение свойства "Hello"

чтобы обратиться к name можем через точку: obj1.name и obj1.someName,
но к someName можно также обратиться как в массиве: obj1['someName']

другой способ это создание через new: new Object();

var obj = new Object();


изменение свойств: 
obj.name= "Some String";


все обьекты созданные при помощи литерала ссылаются на один прототип:
Object.prototype

те которые созданы при помощи new, имеют доступ через prototype получают значения свойств конструктора

var obj3=Object.create(obj1) - создаем новый обьект которы наследует obj1.
Object.create - является статическим методом


удалить свойство можно оператором delete, он он может удалять только собственные свойства, но не унаследованные:

delete obj1.one - удалили свойство у obj1
delete obj3.one -не удалили, т.к. это наследованное свойство.

for (index in object){
	console.log(index + " - " + object[index]);
} - циклический обход по параметрам обьектам



function iteration (object){
	for(index in object){
		if(typeof object[index] == 'object'){
			iteration (object[index]);
		}
		else{
				console.log(index + " - " + object[index]);
		}
	}
} - итерационный обход параметров обьекта


чтобы проверить действительно ли существует свойство у обьекта можно использовать два способа:

if(obj1.one){
	
}
и
if('one' in obj1){
	
} - в этом способе обязательно нужно названия свойств писать в кавычках


разница между ними таково что в первом случае если мы хотим проверить свойство которое на самом деле не существует, то есть undefined мы не увидим результат функционала, а во втором случае if все равно сработает т.к. in проверяет действительность существования свойства не смотря на его значение 

и третий способ 
if(obj1.hasOwnProperty('one')){
	
} - особенность этого метода, в том что он проверяет свойство именно этого обьекта а не наследуемые свойства, например obj3 наследует obj1 тогда 'one' у obj3 не существует таким образом вернется false

создание методов у конкретного обьекта:

var obj4= {
	func : function(){
		alert("hello");
	}
}

и вызывается таким образом: obj4.func();

можно создавать функции за пределами обьекта:

1-   obj4.func2 = function(){
	//
}


2-   function foo() {
	//
}
obj4.func3 = foo; 


чтобы иметь доступ к свойствам внутри функции обьекта, то нужно перед свойство написать this.
obj4.func = function(){
	this.one + this.two
}


свойство getter - это свойство метод, при котором когда мы будем получать само свойство, будет выполняться функция прописанная у нее:

var obj5 = {
	pro1: 20,
	pro2 : 30,

	get sum() {  - само свойство
		return this.pro1+this.pro2;
	}
}

и вызывается вот таким образом:
console.log(obj5.sum);


свойство setter - это свойство метод, вызывается когда мы хотим что то записать в это свойство:
	set sum(value) {
		this.pro1 += value;
		}

	obj5.sum = 100; - то есть мы увеличим pro1 на 100;
	

у свойств обьектов есть 4 атрибута, и назначить эти атрибуты мы можем через методe defineProperty

Object.defineProperty(object, 'property_name', {
	value: 100,
	writable: true, //доступность для записи
	enumerable: true,  // доступность свойства для перечисления for .. in ..
	configurable: true // доступность для настройки
});


функция конструктор - метод который создаст значения всех свойств
function People(name, age){
	this.name=name;
	this.age=age;
} 
далее создаем обьект: var ben= new People("Ben", 18);

также через prototype мы можем дать прототип обьекту, пример у нас есть класс Worker и People у Worker есть свой констуктор, который при вызове создаст прототип на обьект People, для этого нужно сначала обозначить прототип для Worker:

Worker.prototype=People; - то есть говорим то обьект Worker имеет прототип People
Таким образом мы получим доступ к функционалу обьекта People. Можно создать новый метод или свойство для прототипа:
Worker.prototype.giveInfo = function() {
	return this.name + " - " + this.age;
} - таким образом мы создали свойство метод которое вернет инфо о человеке и важно мы это создали внутри класса People а не Worker


}




windows object{
	
	window.location - определяет url текущего окна
	window.document -  обьект документ, отображаемого в окне.
	window.document.getElementById('id') - выборка в документа блока с id
	


	window.setTimeout() - позволяет вызывать функцию через определенное время.
	window.setInterval() - вызывает функцию постоянно через опр время.

	window.onload = function() { - метод который позволяет выполнить функцию как только загрузится страница

	}
	element.style - обращается к стилю элемента
	style.display - правило для аттрибута style элемента

	clearInterval() -функция отменяет ранее запланированный метод

	confirm(); - метод получающий либо true либо false
	prompt(); - метод возвращающий строку полученную от пользователя


	чтобы создать новое окно используем метод : window.open(url, strWindowName,  strWindowFeatures ) и возвращает window обьект представляющее данное окно.
	1 - Если url нету, откроется пустое окно
	2 - Если уже открыто окно, то второй параметр предоставляет доступ к этому окну, если такого нету, то он присвоит это имя новому окну.
	Имя окна хранится в window.name
	3 - необязательный параметр указывающий настройки нового окна, все свойства разделяются запятой

	window.opener содержит родительский обьект window. также к этому обьекту можно запрашивать все переменные и функции
	window.close() - закрывает определенное окно
	window.closed - содержит свойство открыто ли окно или нет

	если мы обьявляем глобальные переменные или функции - то они являются по сути методами и свойствами обьекта window:
	допустим у нас есть обработчик onload(){
		myFunc = function(){
		window.editMyVar();   // где метод editMyVar() обьявлен вне onload
		}
	}

	editMyVar = function(){

	}


	!!!!!! при работе с window обязательно должен быть включен сервер.

	window.frames  - содержит ссылки на дочерние фреймы, то есть на обьекты window. это свойство очень похоже на массив
	window.frames['f1'].getAlert(); - доступ по атрибуту name

	фрейм также может обратиться к родительскому window



	self - обьект текущего window
	top - обьект самого верхнего window
	parent - обьект родительского window

	window.focus() - делает активным окно.
	window.print() - печатает данное окно.
	window.scrollBy(wi, he) - перемещает ползунок на определенное количество пикселей 
	window.scrollTo(wi, he) - устанавливает фиксированное положение.

	window.moveBy(wi, he) - перемещает окно на опр кол-во пикселей.
	window.moveTo(wi, he) - фиксирует перемещенное окно

	window.resizeBy(wi, he) - уменьшает или увеличивает окно
	window.resizeTo(wi, he) - фиксирует уменьшение или увеличение.


	window.innerHeight() - свойство которое возвращает высоту экранной области окна.
	window.innerWidth() - свойство которое возвращает ширину экранной области окна.

	window.outerHeight() - возвращает пиксели внешне полной высоты окна
	window.outerWidth() - возвращает пиксели внешне полной ширины окна
}