открываем <script src='...'> /// </script> если мы добавляем src, то внутри тегов ничего не будет выполняться

обработчики событий также позволяют содавать скрипты:
	<h1 onclick="alert('Hello')">
		Hello
	</h1>

также можно передать на обработку в javascript через тег <a href>:
<a href="JavaScript:alert('другой способ')">js</a>

но в таком виде мы не всегда можем получить что хотим


JavaScript регистрозависимый язык, т.е. правильно надо обозначать все переменные и названия функций

у js есть 2 вида коментариев: строчный и блочный:
// - строчный 
/*      */ -блочный

с помощью var создаем переменную:
var name;
name="iskandar"

неизменяемые типы это логические, числовые, null, булевые, undefined

typeof() метод который показывает тип данных
isNaN() -метод который проверяет если переменная не число то вернет истину
isFinite() - возвращает true если переменная отлична от NaN и бесконечности
конкатинация будет через +: str1 + ' ' + str2;
метод вывода на экран document.write(string);

если мы подключим файл .js в head то вывод document.write будет выходить сразу после тега body
в остальных случаях выводится там же где и он сам

функция Number() переводит что либо в число: Number(null) будет 0
String() наоборот в строку
parseInt()- явное приведение в int, то есть только целую часть: parseInt(10.9) будет 10
parseFloat() - приведение в float

если мы хотим прибавлять строки, то получаем конкатинацию:
'10'+'20' будет 1020
но если умножим то получим '10'*'20' будет 200 и если не получится перевести в числа и умножить то результат будет NaN
если сложим 10+ '20' также будет 1020, т.к. конкатинируются


если например:б
var b=+a;
то b будет уже не строкой а числом

десятичные числа можно также записывать как var a=.2;  и выведется 0.2


методы ввода и вывода:
alert("message") - выводит сообщение и ожидает пока пользователь закроет окно
confirm("message") - предлагает нажимать либо ok либо cancel и возвращает либо истину либо ложь
prompt("message", "default message")- выводит сообщение на экран и ждем ввод произвольной строки и соответственно возвращает данную строку

showModalDialog() - отображает модальное окно в котором можно вводить какой либо текст и позже передать его в скрипт
метод eval() вычисляет числа
инструкция void узнает значение операнда и убирает его, чаще всего применяется в адресах url


массивы - динамические в javascript
var array=[];
var array1=new Array(par1, par2)
var array1=new Array(size)

если мы передадим в document.write(array) - то на экран выведется строка, т.к. массивы это обьекты а у обьектов есть метод toString() который превращает массив в строку

длину массива можно узнать через метод .length: 
var arr=[]
var size=arr.length;

цикл for in применяется для обхода либо массива либо обьекта:
for(var index in array){
	document.write("Индекс массива - "+index);
}

метод join преобразует все элементы массива в строку и разделяет каким нибудь разделителем:
document.write(array.join("-|-")) - значения массива array разделятся такими вот знаками
array.reverse() - переворачивает массив
array.sort() - сортирует по порядку массив
arr.sort([compareFunction]) - если мы предоставим compareFunction то массив будет отсортирован по этой функции:
function compare(a, b) {
  if (a меньше b по некоторому критерию сортировки) {
    return -1;
  }
  if (a больше b по некоторому критерию сортировки) {
    return 1;
  }
  // a должно быть равным b
  return 0;
}

метод arr.concat() - возвращает новый массив с добавленными значениями:
var arr=['a', 'b', 'c'];
var newArr=arr.concat('d', 'e', 'f');
теперь newArr имеет ['a', 'b', 'c', 'd', 'e', 'f'];

метод .slice('начало', 'конец')- выделяет подмассив который будет вырезан из массива:
arr=['a', 'b', 'c', 'd', 'e', 'f'];
var newArr=arr.slice(2,4); - 2 начинается 'c', 4 где заканчивается 'd'
то получим newArr['c', 'd']
если arr.slice(-2, -4)- то slice будет выбирать с конца

метод splice - позволяет и добавлять и удалять исходный массив:
arr.splice('позиция начинания', 'количество элементов которое надо вырезать') - если не передать 2 параметр то удалятся все значения с начинающей позиции

если хотим добавить что либо то:
arr.splice('позиция', 'количество удаления', 'добавка нового значения', ...);
arr.splice(1,0,'c', 'd' ,'e')- то есть после 1 индекса не удаляем ничего а добавляем новые значения c, d, e


arr.push() - добавит в конец массива новые элементы
arr.pop() - удалит с конца массива последний элемент
arr.unshift()- добавит в начало массива новый элемент
arr.shift() - удаляет с начала массива первый элемент

delete arr[index] - удалит значение в индексе, но не удалит саму ячейку, т.е присваиваем в эту ячейку undefined

Array.isArray(arr) - проверит является ли массивом переменная переданная параметром



работа со строками:
т.к. строка это обьект класса String() то мы можем использовать также методы работы с обьектами

str='Искандар'
str[1] // с
то есть как с массивом
но также есть метод str.charAt(1) который также вернет // с

метод concat() - добавит в строку новую часть
str.indexOf('строка')- производит поиск строки которая прописана параметром и возвращает индекс символа с которого начинается строка
str.lastIndexOf('строка') делает то же самое но возвращает последний индекс с которой начинается строка
str.split(',') - разбивает строку по опрделенному разделителю если передать split("") - то он полностью разделит строку на буквы
str.replace('строка которую надо заменить', 'строка на которую надо заменить')- заменяет строку на другую
str.substr('индекс', 'длина')- данный метод возвращает подстроку которая начинается с индекса и с определенной длиной
str.substring('индекс начала', 'индекс конца')- также возвращает подстроку но с начальным и конечным индексом
str.toUpperCase()- переделывает всю строку на прописные буквы
str.toLowerCase() - наоборот в строчные переводит
str.slice()- также вырезает подстроку но отличие от substring в том что slice может принимать отрицательные параметры, которые обозначают выборку с конца: str.slice(-2, -7)- вырезка будет с конца

str.search() - выполняет поиска по шаблону регулярного выражения, если не найдено то возвращает -1
str.match()- также работает как search() возвращает массив совпадений
str.localeCompare(str2)- сравнивает 2 строки. если они полностью идентичны то вернет 0, если менбше то -1, если строка str больше str2 то 1


функции:
если мы хотим передать много параметров в функцию то можно использовать такую конструкцию:
function foo(){
	var array = arguments;
	//код
}
foo(1,2,3,4,5,6,7,8,[1,2,3,4,5,]) - таким образом все параметры попадут в массив arguments;
но если мы не учитываем arguments внутри функции, то все параметры которые не указаны в функции просто будут проигнорированы

вложенные функции имеют доступ к параметром родительской функции


работа с датами:
var now= new Date(); - если вывести на экран то мы увидем время сейчас на английском
now.toLocaleString() - покажет нам время на родном языке
now.toLocaleDateString() - мы увидим только дату
now.toLocaleTimeString() - только время
now.getDate() - вернет число без даты: 2 - то есть 2 февраля
now.getMonth() - вернет месяц: 1 - то есть февраль, потому что в javascript месяцы начинаются с 0-январь
now.getDay() - показывает дни недели: 1-понедельник, 2-вторник и т.д.
now.getFullYear() - показывает год: 2018
now.getYear() - возвращает год от которого вычитается число 1900: т.е. 118
now.getTime() -  вернет количество миллисекунд от 1 января 1970 года
now.getHours() - текущий час
now.getMinutes() - вернет минуты количество минут
now.getSeconds() - вернет количество секунд
now.getMilliseconds()- количество миллисекунд

если те же методы но с приставкой UTC - то получим время по гринвичу
getUTCHours()  и т.д.

можем ввести свой собственный год:
now.setFullYear(1990) - год 1990
now.setMonth(9) - октябрь
now.setDate(25)- то 25 число
день недели нельзя задать
now.setHours()- назначаем часы, если мы поставим число больше чем 24, то JS автоматически поменяет на следующий день и время в остатке
now.setMinutes() - также если превысим минуты то добавит в часы
now.setMilliseconds() - установка миллисекунд
now.setTime() - задаем миллисекунды от 1 января 1970 года

в конструктор Date() можем задать параметры:
var newDate = new Date(2018, 1, 3, 17, 38, 41) - будет 2018 февраля 3 число 17.38.41 - время


таймеры:
setTimeout('метод', периодн времени)- через определенное время будет вызвана функция добавленная в 1 параметр



DOM:
document.getElementById('id'); - получить весь элемент по id, помимо самого элемента мы также получаем доступ к его html коду, типу и количеству дочерних элементов
document.getElementsByTagName('tag') - получаем элемент по тэгу: p, h1, div и т.д. чаще всего вернется массив


var mainTitle=document.getElementById('mainTitle');

alert("This is an element of type : " + mainTitle.nodeType); - тут мы получис номер типа: 1-element, 2-attribute, 3-tag
alert("This inner HTML is : " + mainTitle.innerHTML);- вернет HTML код внутри данной id
alert("Child nodes : " + mainTitle.childNodes.length)- вернет количество дочерних элементов

интересен момент того что .getElementsById можно вызвать не только по Document части DOM, но и по обьектам, пример:
var myList=document.getElementById("listFirst"); - мы принимаем обьект с id = listFirst
var myLiList=myList.getElementsByTagName("li");- а тут мы получаем список обьектов по тэгу ли, но не во всем документе а только у myList


работа с атрибутами:
var myElement= document.getElementById("id1");

myElement.getAttribute("align")- получаем атрибут
myElement.setAttribute("align", "left")- то есть мы настраиваем атрибут и придаем ему значение

создание элементов:
var myElement = documen.getElementsByTagName("ul") - допустим у нас есть элемент с тэгом ul, myElement нас самом деле массив
var myNewElement=document.createElement("li") - создание нового элемента
myNewElement.innerHTML= "Some text"
myElement.appendChild(myNewElement) - мы добавляем в массив myElement новый элемент

или же можно углубленно создать новый элемент, точнее элементы
var myText=document.createTextNode("New li item in text")
myNewElement.appendChild(myText)

алтернативный способ:
parent.insertBefore(newElement, existingElement) - добавляем элемент в документ, но в этом случае мы добавим новый элемент перед существующим
var myNewElement=document.createElement("li")
var existingElement= myElement.getElementsByTagName("li")[1] -  то есть получимв массив с li тэгами и выберем именно вторую ячейку
myElements.insertBefore(myNewElement, existngElement) - добавим перед второй ячейкой


Event Handling:
все события начинаются с on: onClick, onLoad, onScroll и т.д.
но мы должны прописать слушателей событий, т.е. функции которые будут выполняться при определенном событии
1) прописывать слушателя прямо рядом с событием:
onClick="alert('Hello, World!)"
2) создаем элемент и для него прописываем код по событию
var element = document.getElementById("id")
element.onClick=function(){
	//Handler
};
3)пишем метод для элемента, в этом случае огромное преимущество то что для одного события можно создать несколько слушателей:
document/event.addEventListener('click', myFunction, false); - создает слушателя
document/event.removeEventListener('click', myFunction, false); - удаляет слушателя

если мы хотим допустим вызывать alert при нажатии на картинку, то:
var myImage=document.getElementById("mainImage");
myImage.onclick=function(){
	alert("You clicked on image!");
};

если мы вызываем скрипты в документеЮ но доступ дан им в тэгэ head, то пропишем такую логику:

sript.js:
	function prepareEventHandlers(){
	   var myImage=document.getElementById("mainImage");
		myImage.onclick=function(){
		alert("You clicked on image!");
		};
	}

	windows.onload=function(){
		prepareEventHandlers();
	};
суть в том что функция onload будет запускать js код сразу во время загрузки

onFocus и onBlur события, позволяют выполнять опр логику если элемент под фокусом или наоборот оставлен
var emailField=document.getElementById("email");

emailField.onfocus=function(){
	if(emailField.value="your email"){
	emailField="";
	}
};

emailField.onblur=function(){
	if(emailField.value=""){
	emailField="your email";
	}
};

Таймеры:
function simpleMessage(){
	alert('This is just message');
}

есть 2 способа для таймеров- setTimeout() один раз, setInterval() повторяющийся
setTimeout(simpleMessage, 5000) - через 5 секунд мы получим alert()
setInterval(simpleMessage, 5000) - каждые 5 секунд будет появляться alert()

var intervalHandle = setInterval(simpleMessage, 5000)
document.getElementById('image').onclick = function(){
	clearInterval(intervalHandle); 
};
setInterval может возвращать значения а именно какой интервал происходи, и таким образом мы можем остановить таймер



Ошибки:
частые проблемы - 
синтаксические ошибки,
вызов прописными буквами,
использование DOM перед тем как сам документ вызван,



Формы:
получить любое поле формы можно либо через getElementById или document.forms.(имя_name)
textfield: 
	есть значение: textField.value
	можно назначить события: onfocus, onblur, onchange, onkeypress, onkeydown, onkeyup
radio:
	radio.checked
	события: onclick, onchange
select:
	select.type (select-one or select-moltiple)
	select.selectIndex  - можно узнать какой выбор сделан
	select.options[x].selected - для нескольких выборов
	события: onchange

форма:
	события : onsubmit - при нажатии submit если вернем false в обработчике событий, то можно отменить submit


Работа со стилями:
inline свойства можно изменять через подфункцию .style:
element.style.[стиль в css] - element.style.color='#fffff'
одно но, в css стили прописываются через -: font-weight или background-color: в javascript: fontWeight или colorBackground

также можно изменять целые div через стилизирования классов, например:
myElement.className - именно classNmae, т.к. .class нельзя использовать в js




унарные опаерторы: +-*/%, если данные операторы буду выставлены перед строкой, то они попытаются преобразовать строку, и выполнить свою операцию:
если поставить -'5', то сначала '5' превратится в число 5, а потом он станет отрицательняым числом.

если разделить 0/0 то получим NaN, также если попытаемся умножить или разделить строку на число то также получим NaN


в JS + также работает как оператор конкатинации строк, '2'+'3'='23'
при любых случаях если выполняется сложение строки и числа, то + будет работать как оператор конкат. '2' + 3 = '23'

но другие операторы работают как должны '2' - 1 = 1


равентство == и опертор идентичности === сравнивают по особенному:

'10' == 10, т.к при == сначала правая часть переведется в число и потом произойдет сравнение,
'10'=== 10 вернет false,
NaN никогда не равно ничему


при сравнении строк < > исчисляют не количество символов, а по значению символа в ANSI:
'Hello' < 'h' , т.к. h в ANSI больше чем H


анонимные функции:

var func = function(param1, param2){
	///
	///
}  - таким образом мы можетм вызвать определенную функцию через имя переменной

если мы хотим сразу же вызвать функцию при обьявлении, то делаем так:


var func = (function(par1, par2){
	///
	///
} (par1=555, par2 =333));  - то есть обрамляем скобками функцию, и если что то нужно передать то после самой функции мы передаем их


если в функцию мы передаем больше переменных, чем обьявлено изначально, то мы обращаемся к обьекту arguments, при этом это индексный массив:

function func(param1, param2){
	
	arguments;

	return param1+param2+arguments[2];
}


func(1,2,3,4,5,6,7,8,0)


методы для работы с массивами:
.. in array, метод in просматривает определенный атрибут в массиве, (3 in arr2) если действительно 3 есть то in вернет true

Array.isArray(массив)- вернет true, если проверяемый массив является действительно массивом

arr.join(разделитель) - превращает все атрибуты массива в строку обьединяет их и возвращает строку.  arr.join('-') - соединит все элменты массива через -


arr.reverse()- переворачивает все элементы в массиве.


arr.sort(порядок) - возвращает отсортированный массив, если без параметров то сортирует по возрастанию, 

arr.sort(function(a,b){
	return a-b // отсортирует по возрасатанию
	return b-a // отсортирует по убыванию
}) 


arr.concat() - сливает 2 массива или массив с последувотельностью элементов


arr.slice() - возвращает фрагмент или подмассив указаноого массива, параметры a= первый элемент для проверки, b = последний элемент, но не включается
var frag= arr.slice(a, b) если писать с минусом то он будет выбирать с конца

splice() - производит вставку или удаляет элементы массива, возвращает те элементый которые были удалены
arr.splice(a, b, c,d,e,f,...) - a= обьявляет первый элемент с какого надо считать, b= количество удаляемых элементов, если не передавать 2 параметр, то splice удалит все элементы начиная с a. следующие элементы после b это те элементый которые будут добавлены в массива


arr.push(элементы) - добавляет в конец массива элементы, и возвращает новую длину массива

arr.pop() - удаляет последний элемент массива, и вовзр. длину массива


arr.unshift(элементы) - добавляет элементы в начало массива

arr.shif() - удаляет первый элемент и возвращает его, все элементы смещаются в индексе

delete arrp4 - удаляет элемент массива,



arr.forEach(function(value, index, a){
	
});

arr.map(function(value, index, a){
	
	return value * value;

}); - работает так же  как foreach, но функция внутри возвращает новый массив.


arr.filter(function(value, index, a){
	
	return value<5;

}); - возвращает массив содержащий опр количество элементов исходного массива, работает также как foreach но функция должна возвращать истину что элемент вошел в новый массив


arr.every(function(value, index, a){
	
	return x<5;

})- возвращает истину, если передаваемая функция возвр истину для всех элементов массива


arr.every(function(value, index, a){
	
	return x<5;

}) - возвращает истину, если хотя бы один элемент истина


arr.reduce(function(x,y){

return x+y;

}, 0) - используется для обьединения массива, используя функцию



arr.indexOf(value) - возвращает индекс от, начала массива к концу и ищет то самое значение
arr.lastIndexOf(value)- в обратном порядке


for(var key in arr){
	document.write(key+ ' => '+arr[key]+'<br>'+);
}




String{
	
	строка это обьект класса String, и к ней мы имеем доступ в виде массива:
	str[10]; или str.charAt(10);

	str.concat('text', 'text2', ...) - метод обьединения строк, принимает параметром строки которые нужно добавить


	str.indexOf('substr', 'position') - метод нахождения подстроки в строке, и возвращает позицию начала подстроки, если не найдены то возвращает -1, также можно передать начальную позицию с которой надо начинать поиск

	str.lasIndexOf('substr', 'postion')- то же самое но с конца

	str.length() - возвращает количество символов

	str.localeCompare('str1') - сравнивает с учетом локализации две строки, str и str1, если str>str1 то вернет 1, если две разные локализации, то вернет -1

   примеры использования:
   strings=['мир', 'привет', 'сравнение', 'что-то изучаем'];

   strings=strings.sort(function (a,b) {

   		return a.localeCompare(b);
   })

   таким образом мы отсортируем массив strings по порядку и длине строк


   str.match(regexp) - возвращает массив результатов поиска, зависит от добавления g в regexp
   str.replace(regexp, 'replacement') - заменяет результаты поиска
   str.search(regexp) - возвращает позицию начала первой подстроки соответствующей regexp, игнорирует флаг g, -1 если не найдет
   str.slice(index, last_index) - возвращает подстроку, где index это начало срезания, last_index это конечный индекс, который не попадает в новую подстроку.
   str.split(delimiter, num_of_elements) - делит строку на массив где delimeter разделитель
   str.substr(index, number) - берет substring с index начала и количеством number
   str.toLocaleLowerCase() - переводит все символы с маленькой буквы
   str.toLocaleUpperCase() - наоборот




}



Обьекты {
	
обьекты создаются: использование литерал обькта {} - заклыченный в эти скобки список свойств

var obj = {
	
};

свойтсва даются через такой способ:

var obj1 = {
	name : "Hello",
	'someName' : "World"
} - тут мы видим что name это имя свойства, далее : и далее само значение свойства "Hello"

чтобы обратиться к name можем через точку: obj1.name и obj1.someName,
но к someName можно также обратиться как в массиве: obj1['someName']

другой способ это создание через new: new Object();

var obj = new Object();


изменение свойств: 
obj.name= "Some String";


все обьекты созданные при помощи литерала ссылаются на один прототип:
Object.prototype

те которые созданы при помощи new, имеют доступ через prototype получают значения свойств конструктора

var obj3=Object.create(obj1) - создаем новый обьект которы наследует obj1.
Object.create - является статическим методом


удалить свойство можно оператором delete, он он может удалять только собственные свойства, но не унаследованные:

delete obj1.one - удалили свойство у obj1
delete obj3.one -не удалили, т.к. это наследованное свойство.

for (index in object){
	console.log(index + " - " + object[index]);
} - циклический обход по параметрам обьектам



function iteration (object){
	for(index in object){
		if(typeof object[index] == 'object'){
			iteration (object[index]);
		}
		else{
				console.log(index + " - " + object[index]);
		}
	}
} - итерационный обход параметров обьекта


чтобы проверить действительно ли существует свойство у обьекта можно использовать два способа:

if(obj1.one){
	
}
и
if('one' in obj1){
	
} - в этом способе обязательно нужно названия свойств писать в кавычках


разница между ними таково что в первом случае если мы хотим проверить свойство которое на самом деле не существует, то есть undefined мы не увидим результат функционала, а во втором случае if все равно сработает т.к. in проверяет действительность существования свойства не смотря на его значение 

и третий способ 
if(obj1.hasOwnProperty('one')){
	
} - особенность этого метода, в том что он проверяет свойство именно этого обьекта а не наследуемые свойства, например obj3 наследует obj1 тогда 'one' у obj3 не существует таким образом вернется false

создание методов у конкретного обьекта:

var obj4= {
	func : function(){
		alert("hello");
	}
}

и вызывается таким образом: obj4.func();

можно создавать функции за пределами обьекта:

1-   obj4.func2 = function(){
	//
}


2-   function foo() {
	//
}
obj4.func3 = foo; 


чтобы иметь доступ к свойствам внутри функции обьекта, то нужно перед свойство написать this.
obj4.func = function(){
	this.one + this.two
}


свойство getter - это свойство метод, при котором когда мы будем получать само свойство, будет выполняться функция прописанная у нее:

var obj5 = {
	pro1: 20,
	pro2 : 30,

	get sum() {  - само свойство
		return this.pro1+this.pro2;
	}
}

и вызывается вот таким образом:
console.log(obj5.sum);


свойство setter - это свойство метод, вызывается когда мы хотим что то записать в это свойство:
	set sum(value) {
		this.pro1 += value;
		}

	obj5.sum = 100; - то есть мы увеличим pro1 на 100;
	

у свойств обьектов есть 4 атрибута, и назначить эти атрибуты мы можем через методe defineProperty

Object.defineProperty(object, 'property_name', {
	value: 100,
	writable: true, //доступность для записи
	enumerable: true,  // доступность свойства для перечисления for .. in ..
	configurable: true // доступность для настройки
});


функция конструктор - метод который создаст значения всех свойств
function People(name, age){
	this.name=name;
	this.age=age;
} 
далее создаем обьект: var ben= new People("Ben", 18);

также через prototype мы можем дать прототип обьекту, пример у нас есть класс Worker и People у Worker есть свой констуктор, который при вызове создаст прототип на обьект People, для этого нужно сначала обозначить прототип для Worker:

Worker.prototype=People; - то есть говорим то обьект Worker имеет прототип People
Таким образом мы получим доступ к функционалу обьекта People. Можно создать новый метод или свойство для прототипа:
Worker.prototype.giveInfo = function() {
	return this.name + " - " + this.age;
} - таким образом мы создали свойство метод которое вернет инфо о человеке и важно мы это создали внутри класса People а не Worker


}




windows object{
	
	window.location - определяет url текущего окна
	window.document -  обьект документ, отображаемого в окне.
	window.document.getElementById('id') - выборка в документа блока с id
	


	window.setTimeout() - позволяет вызывать функцию через определенное время.
	window.setInterval() - вызывает функцию постоянно через опр время.

	window.onload = function() { - метод который позволяет выполнить функцию как только загрузится страница

	}
	element.style - обращается к стилю элемента
	style.display - правило для аттрибута style элемента

	clearInterval() -функция отменяет ранее запланированный метод

	confirm(); - метод получающий либо true либо false
	prompt(); - метод возвращающий строку полученную от пользователя


	чтобы создать новое окно используем метод : window.open(url, strWindowName,  strWindowFeatures ) и возвращает window обьект представляющее данное окно.
	1 - Если url нету, откроется пустое окно
	2 - Если уже открыто окно, то второй параметр предоставляет доступ к этому окну, если такого нету, то он присвоит это имя новому окну.
	Имя окна хранится в window.name
	3 - необязательный параметр указывающий настройки нового окна, все свойства разделяются запятой

	window.opener содержит родительский обьект window. также к этому обьекту можно запрашивать все переменные и функции
	window.close() - закрывает определенное окно
	window.closed - содержит свойство открыто ли окно или нет

	если мы обьявляем глобальные переменные или функции - то они являются по сути методами и свойствами обьекта window:
	допустим у нас есть обработчик onload(){
		myFunc = function(){
		window.editMyVar();   // где метод editMyVar() обьявлен вне onload
		}
	}

	editMyVar = function(){

	}


	!!!!!! при работе с window обязательно должен быть включен сервер.

	window.frames  - содержит ссылки на дочерние фреймы, то есть на обьекты window. это свойство очень похоже на массив
	window.frames['f1'].getAlert(); - доступ по атрибуту name

	фрейм также может обратиться к родительскому window



	self - обьект текущего window
	top - обьект самого верхнего window
	parent - обьект родительского window

	window.focus() - делает активным окно.
	window.print() - печатает данное окно.
	window.scrollBy(wi, he) - перемещает ползунок на определенное количество пикселей 
	window.scrollTo(wi, he) - устанавливает фиксированное положение.

	window.moveBy(wi, he) - перемещает окно на опр кол-во пикселей.
	window.moveTo(wi, he) - фиксирует перемещенное окно

	window.resizeBy(wi, he) - уменьшает или увеличивает окно
	window.resizeTo(wi, he) - фиксирует уменьшение или увеличение.


	window.innerHeight() - свойство которое возвращает высоту экранной области окна.
	window.innerWidth() - свойство которое возвращает ширину экранной области окна.

	window.outerHeight() - возвращает пиксели внешне полной высоты окна
	window.outerWidth() - возвращает пиксели внешне полной ширины окна

	window.location - ссылается на обьект location представляющий текущий url адрес отображающийся в строке браузера, также определяет методы инициализурующие загрузку нового документа в окно браузера
	также к location можно обратиться и без window

	у document также есть свойство location: document.location

	свойства location:
		location.href - содержит строку полного url адресса 
		location.toString() - возвращает значение href
		location.host -  содержит имя домена вместе с портом
		location.hostname - содержит только имя домена
		location.pathname - содержит путь к данному документу
		location.protocol - имя протокола
		location.hash - возвращает индентификатор фрагмента: js.test/#top , где #top - это индетификатор фрагмент
		location.search - содержит часть url адресса следующая за вопросительным знаком: js.test/?id=1, где search вернет ?id=1


		методы location:
		location.assign()
		location.replace()
		location.reload() - заставляет обновить вкладкуы

		window.location = "" ; - мы можем напрямую записать


	обьект history:
		history - хранит историю просмотра страниц
		history.length - содержит кол-во элементов в списке истории

		history.back() - возвращемся на пред документа который мы просматривали
		history.forward() - перевод вперед
		history.go(integer) - пропускает заданное число страниц, передвигаемся вперед если аргумент положительный по списку

	обьект navigator:
		window.navigator - содержит общую инфу о браузере 
		navigator.appName - содержит имя приложения


	обьект screen:
		window.screen - представляет инфу о размере экрана и доступности цветов у клиента

		screen.width - ширина экрана в пикселях
		screen.height - высота
		screen.availHeight - доступный размер экрана
		screen.availWidth 
		screen.colorDepth - глубина цвета
}


DOM{
	document.getElementById('id') -> выбираем элемент по id возвращает обьект Element

	document.getElementByName('name') - выбираем элемент по name атрибуту, возвращается массив выбранных элементов виде обьекта NodeList, при этом любые изменения будут сразу же отображаться в обьект NodeList т.е. живой массив	

	document.getElementsByTagName('tags') - возвращает все элементы под тегом. также возвращается NodeList. также мы можем выбирать элементы под категорией, то есть можем делать выборку относительно родительского блока.

	document.images - получаем доступ к html коллекции всех изображений на этой странице.
	document.links - коллекция a ссылок
	documnet.forrms - коллекция элементов формы

	document.getElementsByClassName ('class') - выборка по именни класса

	
	селекторы: выборка производится по :
		1. p div h1 - по тегам
		2. #id .class - по id и class
		3. input[name='email'] - по параметрам name

	document.querySelectorAll('селектор') - возвращает обьект NodeList который хранит все значения по селектору, но он не живой и возвращает только то что было сохранено на момент вызова.

	document.querySelector() - получаем только первый элемент 

	также можно дальше вызывать по цепочке этот метод, т.к он возвращает element обьект 
	element.parentNode - возвращает родительский элемент

	element.childNodes - вовзвращает все дочерние элементы в том числе текстовые и т.д. в виде NodeList, если есть коментарии они тоже принимаются в узле comments
	element.firstChild - возвращает первый дочерний узел
	element.lastChild - возвращает последний дочерний узел
	element.nextSibling - возвращает следующий братский узел
	element.previousSibling - возвращает предыдущий братский узел

	element.nodeValue - возвращает значение node
	element.nodeName - возвращает имя node с заглавной буквы : A, DIV, LI
	element.nodeType - возвращает тип : 1 - element, 9 - document, 3- текстовые, 8- коменты

	element.children - возвращает NodeList, разница с childNodes в том что возвращается только элементы node
	element.firstElementChild - вернет первый дочерний элемент
	element.lastElementChild - последний дочерний элемент
	element.nextElementSibling - следующий братский элемент
	element.previousElementSibling - предыдущий
	children.length - количество обьектов в массиве

	element.id - возвращает id элемента, также можно дать новое значение, element.id = "hello"
	document.forms[0].id -также вернет id формы
	element.action - возвращает action атрибут
	.href,  но например for="" в js нельзя выбирать так как оно зарезервировано под цикл, вместо этого нужно написать .htmlFo и в других случаях для доступа к зарезервированым словам нужно писать html'Attr' перед самим словом

	element.setAttribute('attribute', 'value') - метод который назначит аттрибут для элемента
	element.getAttribute('attribute') - возврвщает значение аттрибута элемента
	element.hasAttribute('attribute') - проверяет есть ли такой аттрибут у элемента
	element.removeAttribute('attribute')- удаляет данный аттрибут

}

содержимое HTML элементов{
	содержимое элемента можно в 3 вариантах: 
	1- HTML
	2- в виде простого текста
	3-  в виде текстового узла

	element.innerHTML - возвращает HTML код
	<a href="index-1.html">About</a>
	если мы попытаемся поменять innerHTML - то мы просто введем текст вместо html кода

	element.outerHTML - получаем строку разметки html содержащий открывающий и закрывающий теги
	<li id="myLi" class="current"><a href="index-1.html">About</a></li>

	element.insertAdjacentHTML("position", 'html'); -добавляет разметку на определенную позицию
	position может быть : beforebegin-перед откр тегом, afterbegin-после откр тега, beforeend-перед закр тегом, afterend-после закр тега

	element.textContent - возвращает текстовое значение элемента:
	About

	также можно спокойно изменять значение этого свойтсва: element.textContent = "hello";
	element.innerText = "hello" - свойство используется для internet explorer

	при сохранении полученного результата от этих двух свойств, 1 textContent учитывает табуляции, строки, и пробелы все, 2 innerText - форматирует так что нету табуляции и лишних пробелов	

	document.createElement('div') - создает новый элемент
	document.createTextNode('text body') - создает новый текстовый узел
	document.createComment('comment') - создает коментовый узел
	document.createDocumentFragment() - создает фрагмент

	document.cloneNode(type); - копирует обьект и сохраняет в другой, но он не копирует дочерние элементы, если первым аргументом вместо type пропишем true то он рекурсивно будет копировать

	чтобы добавить узлы в документ html используя методы:
	element.appendChild(node) - становится последним дочерним узлом элемента
	element.insertBefore(вставляемы узел, узел перед которым вставляется)- внутри element добавится новый элемент который будет дочерним для element, если второй параметр будет null - то он добавится в конец дочерних элементов

	если же элемент который хотим вставить уже существует, то мы можем перемещать его просто вдоль element:
	wrap.insertBefore(h2, null);

	<div class="wrap">
	...
	..
	<h2> Hello </h2>
	</div>


	element.removeChild(h1); - удаляет дочерний элемент у Element
	element.replaceChild(remove, replace) - у element удаляет дочерний элемент и заменяет replace элементом


	document fragment служат временным хранилищем для других узлов, яв-ся самостоятельным и не входят в состав другого документа. то есть нет родителя


}


формы {
	

	у всех обьектов form есть свойство .type которое хранит значение атрибута type

	получить форму через document.formName, где formName это свойство name у формы

	document.forms - содержит в себе коллекцию всех форм в документе: document.forms[0] или document.forms.formName - вызов по имени формы

	у форм есть также дочерние элементы: input и т.д. их можно получить опять таки по имени тега: document.forms.formName.email - получим input с именем email
	дальше по цепочке у email можно получить все свойства input: document.forms.formName.email.type или document.forms.formName.email.value

	НО! желательно получать все элементы по id

	если же мы попробуем получить по name и если существует несколько тегов с одним именем, то мы получим коллекцию RadioNodeList со всеми элементами с одинаковым name

	у checkbox элментов есть свойство defaultChecked - которое возвращает истину если данная опция по дефолту выбрана: forms.formName.option.defaultChecked

	для получения абсолютно всех элементов формы можно вызвать свойство elements которое вернет коллекцию HTMLFormControlsCollection: document.forms.formName.elements и доступ к каждому элементу можно получить по индексу или по name, также можно узнать количество элементов внутри коллекции через свойство elements.length
	но если вызовем length у формы просто то также получим количество как в elements.length

	доступ к аттрибутам в теге <form> можно получить через свойство обьекта:
	var form = document.forms.firstForm;
	console.log(form.action);
	console.log(form.target);
	console.log(form.method);

	методы form:
	form.submit() - отправляет форму
	form.reset() - обнуляет форму


	есть общие свойства которые определены у каждого элемента у формы document.forms.formName.email.:
	type, form - ссылка на родительский обьект формы, name, value - мы также можем изменять value="text";

	у элементов select если есть multiple="true", то при вызове select.type нам выведтся строка : select-multiple в ином случае select-one
	у элемента select есть свойство .options которое возвращает коллекцию HTMLOptionsCollection которое хранит значение тегов option, если же мы не работает с select-multiple, то свойство .selectedIndex вернет значение выбраного option

	у options свойства есть другое свойство .selected - которое возвращает правду если данный option выбран: select.option[0].selected , свойство .text у select покажет видимый текст у option


	также у тега select можно изменить или добавить количество опций:
	var select = document.forms.firstForm.elements.mySelect
	select.length - длина селекта, если же будем изменять данное свойство то мы можем так изменять количество опций

	если же хотим удалить конкретный option, то нужно присвоить данному элементу null: select.options[2] = null;

	создание обьекта option:
	var newOption = new Option('text', 'value', '(boolean)defaultSelected', '(boolean)shouldItBeSelected'); для того чтобы связать данный option с селектом, то мы
	выбираем просто сам селект и его options и по индексу добавляем: select.options[0] = newOption;


}

события{
	события не являются обьектами js, события имеют тип события: mousemove - перемещен указатель мыши, keydown - была нажата клавиша, load - произошла загрузка тип события также называется имя. Цель события - для чего создано событие  обьекты document, window, element вызвают события. функции обработчики должны указать тип события и цель. Обьект события передаются в функции обработчики первой переменной.

	onclick свойство элемента, которому можем присвоить функцию обработчик события

	вызывать функцию обработчик можно либо отдельно в скрипте .js либо как атрибут в html теге: но различие в том что в html теге мы прописываем название функции.

    1-	var button = document.querySelector(".btn-default");
	button.onclick = function(){
		document.forms[0].submit();
	}
    2-	<button type="button" onclick="document.forms[0].submit()" class="btn btn-default">Submit</button>


	существуют типы событий которые вызываюстя для браузера в целом, такие события обьявляются только с обьектом window и только в <body>
	это события: onafterprint, onfocus, ononline, и т.д.

	e.srcElement - возвращает элемент на который было произведено событие

	другой способ регистрации события через метод addEventListener:
	button.addEventListener('type of event(click)', callback function(function){
		обработка события
	}, false);

	с помощью данного способа можно зарегистрировать несколько обработчиков событий для одного действия. Но одну и туже функцию не получится зарегистрировать дважды

	.removeEventListener('event', delete function, false) - удаляет обработчик события
	}


обработчик событий {

		в функцию обработчик первым параметром передается обьект события, с которым будем работать дальше
		чтобы была кроссбраузерная разработка желательно использовать метод attachEvent - для IE

		внутри функции обработчика можно обратиться к цели события т.е. к самому элементу на которую создана эта функция через метод this

		button.addEventListener('click', handler, false);

		function handler(e){
		console.log(this);
		}

		но метод attachEvent() вызывается как функция и поэтому она не ссылается this к самому элементу, а к обьекту window

		метод call() - применяется для вызова функции в контексте определенного обьекта, где первым свойством передается сам обьект. он возвращает как бы вызов функции.

		у обработчиков событий есть свои области видимости, где они определяются, а не где вызываются. Для аттрибута onClick в html область видимости это глобальная область в самом файле js, свойства document например getElementById(), this в этом случае будет сам элемент у которого прописывается аттрибут, также можно обращаться к элементам формы по их id если аттрибут у элемента в форме.

		предотвратить отправку формы можно если мы вернем false при каком то событии, также это работает в js файле с свойством onclick у обьектов.: 
		button.onclick=function(e){
		return false;
		}


		при нажатии на клавиши происходит событие onkeypress и при этом если обработчик события вернет false, то мы отменяем стандартное поведение или ввод данных. пример:

		document.forms.myForm.elements.exampleInputEmail.onkeypress = function(e) {
			if(e.charCode == 100){
				return false;
			}
			else{
				return true;
			}
		} то есть мы запрещаем ввод буквы d

		для каждого символа введеного клавиатурой есть код e.charCode ASCII 

		событие onbeforeonload оно генерируется при переходе на другую страницу но работает только для IE


		отменить действия по умолчанию можно методом preventDefault() обьекта события. выполняется для всех браузеров поддерживающих addEventListener()

		для IE не работает но можно по другому остановить действие. нужно свойству event.returnValue присвоить false


		e.defaultPrevented - содержит false и принимает true когда вызывается event.preventDefault()


		event.target - показывает непосредственно сам элемент у которого было вызвано событие

		порядок выполнения обработчика:
		1 - вызывается html аттрибуты или с помощью свойств обьектов типа: button.onclick
		2 - вызываются обаботчики через addEventListener, в порядке их регистрации
		3 - вызываются attachEvent и они вызываются в разном порядке

}


фазы распространения событий{
	3 фаза- события элемента всплывают по DOM:
		допустим у нас 3 блока div(p(span)) в таком порядке и для каждого из них мы описали функцию обработчик. суть в том что допустим мы кликнем на span наш обработчик пойдет наверх по иерархии пока не дойте до документ, вызвав другие обработчики.

		То есть родительские элементы если имеют обработчик события, то он тоже будет вызван при вызове обработчика события целевого элемента.

		Таким образом можно описать один единственный обработчик у родителя который будет обрабатывать все дочерние события. НО this внутри функции обработчика будет тот элемент у которого будет прописано обработчик события.

		если же мы хотим остановиться на каком то обработчике, то должны использовать метод .stopPropagation(); - который и остановит обработчики. Данный метод имеет место только для тех браузеров которые поддерживают addEventListener(). кроме stopPropagaion() есть еще метод cancelBubble = true;
	

		Вся эта фаза называется ВСПЛЫТИЕ!!

	2 - Вызов обработчика целевого обьекта





	1- фаза перехвата

		если поставим true в третьем параметре метода addEventListener() - то таким образом обработчик события будет числиться как перехватчик события. в этой фазе учасвтсуют только обработчики событий: порядок выполнения обработки идет с верху и вниз, window->document->body->element.

		Перехватчик может использоваться для безопастно: 
}



события мыши {

	click - срабатывает, когда нажимают и отпускают кнопку мыши.
	contextmenu - срабатывает перед выводом контекстного меню
	dblclick - срабатывает когда пользователь выполняет двойной клик
	mousedown - срабатывает когда нажимает кнопку.
	mouseup - срабатывает когда отпускают кнопку.
	mousemove - срабатывает когда перемещают мышку.
	mouseover - срабатывает когда указатель помещается над элементом.
	mouseout - срабатывает когда указатель покидает элемент.
	mouseenter - подобно mouseover но не всплывает по дереву DOM.
	mouseleave - подобно mouseout но не всплывает по дереву DOM.

	у события click есть очень много параметров:
	target - цель на которую нажали
	ctrlKey - показывает true если при клике была зажата ctrl
	detail - показывает количество щелчков подряд 
}



события клавиатуры {
	onkeypress - событие при нажатии и отпуска, содержит тот символ на который было нажато в виде юникода в свойстве charCode
		key: название буквы
		code: 'Key-буква'
		charCode: юникод число буквы - для мозилы
		keyCode: юникод число клавиши для остальных

	onkeyup - клавиша отпущена
	onkeydown - клавиша нажата
		keyCode - код клавиши, очень важно что charCode у keydown нету

	String.fromCharCode(e.charCode) - позволяет отобразить в js тот символ на который мы нажали
	если нужно сохранить в массив, то используем метод push(string);
}

события формы {
	
	onsubmit - срабатывает во время отправки формы
	onreset - возбуждается когда сбрасываем форму
	onchange - возбуждается когда изменяется состояние определенного элемента формы: выбираем checkbox, input прописываем и т.д.
	onfocus - возбуждается когда передается фокус к определенному элементу формы
	onblue - возбуждается когда теряется фокус
	oninput - срабатывает когда добавляем что то в input
	oninput="this.value = this.value.toUpperCase();" - меняем value на верхний регистр

}


