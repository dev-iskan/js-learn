Бенчмаркинг
Допустим, у нас есть несколько вариантов решения задачи, каждый описан функцией.
Как узнать, какой быстрее?

Для примера возьмем две функции, которые бегают по массиву:

  function walkIn(arr) {
    for (var key in arr) arr[key]++
  }

  function walkLength(arr) {
    for (var i = 0; i < arr.length; i++) arr[i]++;
}
Чтобы померять, какая из них быстрее, нельзя запустить один раз walkIn, один раз walkLength и замерить разницу. Одноразовый запуск ненадежен, любая мини-помеха исказит результат.

Для правильного бенчмаркинга функция запускается много раз, чтобы сам тест занял существенное время. Это сведет влияние помех к минимуму. Сложную функцию можно запускать 100 раз, простую – 1000 раз…
Померяем, какая из функций быстрее:

   var arr = [];
  for (var i = 0; i < 1000; i++) arr[i] = 0;

  function walkIn(arr) {
    for (var key in arr) arr[key]++;
  }

  function walkLength(arr) {
    for (var i = 0; i < arr.length; i++) arr[i]++;
  }

  function bench(f) {
    var date = new Date();
    for (var i = 0; i < 10000; i++) f(arr);
    return new Date() - date;
  }

  alert( 'Время walkIn: ' + bench(walkIn) + 'мс' );
  alert( 'Время walkLength: ' + bench(walkLength) + 'мс' );


Теперь представим себе, что во время первого бенчмаркинга bench(walkIn) компьютер что-то делал параллельно важное (вдруг) и это занимало ресурсы, а во время второго – перестал. Реальная ситуация? Конечно реальна, особенно на современных ОС, где много процессов одновременно.

Гораздо более надёжные результаты можно получить, если весь пакет тестов прогнать много раз.

    var arr = [];
    for (var i = 0; i < 1000; i++) arr[i] = 0;

    function walkIn(arr) {
      for (var key in arr) arr[key]++;
    }

    function walkLength(arr) {
      for (var i = 0; i < arr.length; i++) arr[i]++;
    }

    function bench(f) {
      var date = new Date();
      for (var i = 0; i < 1000; i++) f(arr);
      return new Date() - date;
    }

    // bench для каждого теста запустим много раз, чередуя
    var timeIn = 0,
      timeLength = 0;
    for (var i = 0; i < 100; i++) {
      timeIn += bench(walkIn);
      timeLength += bench(walkLength);
    }

    alert( 'Время walkIn: ' + timeIn + 'мс' );
    alert( 'Время walkLength: ' + timeLength + 'мс' );


  Более точное время с performance.now()
В современных браузерах (кроме IE9-) вызов performance.now() возвращает количество миллисекунд, прошедшее с начала загрузки страницы. Причём именно с самого начала, до того, как загрузился HTML-файл, если точнее – с момента выгрузки предыдущей страницы из памяти.
Так что это время включает в себя всё, включая начальное обращение к серверу.
Его можно посмотреть в любом месте страницы, даже в <head>, чтобы узнать, сколько времени потребовалось браузеру, чтобы до него добраться, включая загрузку HTML.
Возвращаемое значение измеряется в миллисекундах, но дополнительно имеет точность 3 знака после запятой (до миллионных долей секунды!), поэтому можно использовать его и для более точного бенчмаркинга в том числе.


  console.time(метка) и console.timeEnd(метка)
Для измерения с одновременным выводом результатов в консоли есть методы:
console.time(метка) – включить внутренний хронометр браузера с меткой.
console.timeEnd(метка) – выключить внутренний хронометр браузера с меткой и вывести результат.
Параметр "метка" используется для идентификации таймера, чтобы можно было делать много замеров одновременно и даже вкладывать измерения друг в друга.
В коде ниже таймеры walkIn, walkLength – конкретные тесты, а таймер «All Benchmarks» – время «на всё про всё»:

   var arr = [];
  for (var i = 0; i < 1000; i++) arr[i] = 0;

  function walkIn(arr) {
    for (var key in arr) arr[key]++;
  }

  function walkLength(arr) {
    for (var i = 0; i < arr.length; i++) arr[i]++;
  }

  function bench(f) {
    for (var i = 0; i < 10000; i++) f(arr);
  }

  console.time("All Benchmarks");

  console.time("walkIn");
  bench(walkIn);
  console.timeEnd("walkIn");

  console.time("walkLength");
  bench(walkLength);
  console.timeEnd("walkLength");

  console.timeEnd("All Benchmarks");
При запуске этого примера нужно открыть консоль, иначе вы ничего не увидите.



Внимание, оптимизатор!
Современные интерпретаторы JavaScript делают массу оптимизаций, например:

1 - Автоматически выносят инвариант, то есть постоянное в цикле значение типа arr.length, за пределы цикла.
2 - Стараются понять, значения какого типа хранит данная переменная или массив, какую структуру имеет объект и, исходя из этого, оптимизировать внутренние алгоритмы.
3 - Выполняют простейшие операции, например сложение явно заданных чисел и строк, на этапе компиляции.
4 - Могут обнаружить, что некий код, например присваивание к неиспользуемой локальной переменной, ни на что не влияет и вообще исключить его из выполнения, хотя делают это редко.

Эти оптимизации могут влиять на результаты тестов, поэтому измерять скорость базовых операций JavaScript («проводить микробенчмаркинг») до того, как вы изучите внутренности JavaScript-интерпретаторов и поймёте, что они реально делают на таком коде, не рекомендуется.