	Методы объектов, this
До этого мы говорили об объекте лишь как о хранилище значений. Теперь пойдём дальше и поговорим об объектах как о сущностях со своими функциями («методами»).

	Методы у объектов
При объявлении объекта можно указать свойство-функцию, например:

	var user = {
	  name: 'Василий',

	  // метод
	  sayHi: function() {
	    alert( 'Привет!' );
	  }

	};

	// Вызов
	user.sayHi();

Свойства-функции называют «методами» объектов. Их можно добавлять и удалять в любой момент, в том числе и явным присваиванием:
   var user = {
	  name: 'Василий'
	};

	user.sayHi = function() { // присвоили метод после создания объекта
	  alert('Привет!');
	};

	// Вызов метода:
	user.sayHi();




	Доступ к объекту через this
Для полноценной работы метод должен иметь доступ к данным объекта. В частности, вызов user.sayHi() может захотеть вывести имя пользователя.
Для доступа к текущему объекту из метода используется ключевое слово this.
Значением this является объект перед «точкой», в контексте которого вызван метод, например:

    var user = {
     name: 'Василий',

     sayHi: function() {
      alert( this.name );
     }
    };

    user.sayHi(); // sayHi в контексте user

Здесь при выполнении функции user.sayHi() в this будет храниться ссылка на текущий объект user.

Вместо this внутри sayHi можно было бы обратиться к объекту, используя переменную user:

	  sayHi: function() {
	    alert( user.name );
	  }

…Однако, такое решение нестабильно. Если мы решим скопировать объект в другую переменную, например admin = user, а в переменную user записать что-то другое – обращение будет совсем не по адресу:

    var user = {
	  name: 'Василий',

  	sayHi: function() {
	    alert( user.name ); // приведёт к ошибке
	  }
	};

	var admin = user;
	user = null;

	admin.sayHi(); // упс! внутри sayHi обращение по старому имени, ошибка!


Использование this гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана.
Через this метод может не только обратиться к любому свойству объекта, но и передать куда-то ссылку на сам объект целиком:

	var user = {
	  name: 'Василий',

	  sayHi: function() {
	    showName(this); // передать текущий объект в showName
	  }
	};

	function showName(namedObj) {
	  alert( namedObj.name );
	}

	user.sayHi(); // Василий


	Подробнее про this
Любая функция может иметь в себе this. Совершенно неважно, объявлена ли она в объекте или отдельно от него.
Значение this называется контекстом вызова и будет определено в момент вызова функции.

Например, такая функция, объявленная без объекта, вполне допустима:

   function sayHi() {
	  alert( this.firstName );
	}

Эта функция ещё не знает, каким будет this. Это выяснится при выполнении программы.
Если одну и ту же функцию запускать в контексте разных объектов, она будет получать разный this:

	var user = { firstName: "Вася" };
	var admin = { firstName: "Админ" };

	function func() {
	  alert( this.firstName );
	}

	user.f = func;
	admin.g = func;

	// this равен объекту перед точкой:
	user.f(); // Вася
	admin.g(); // Админ
	admin['g'](); // Админ (не важно, доступ к объекту через точку или квадратные скобки)

Итак, значение this не зависит от того, как функция была создана, оно определяется исключительно в момент вызова.



	Значение this при вызове без контекста
Если функция использует this – это подразумевает работу с объектом. Но и прямой вызов func() технически возможен.
Как правило, такая ситуация возникает при ошибке в разработке.

При этом this получает значение window, глобального объекта:

	 function func() {
	  alert( this ); // выведет [object Window] или [object global]
	}

	func();

Таково поведение в старом стандарте.
А в режиме use strict вместо глобального объекта this будет undefined:

	 function func() {
	  "use strict";
	  alert( this ); // выведет undefined (кроме IE9-)
	}

	func();

Обычно если в функции используется this, то она, всё же, служит для вызова в контексте объекта, так что такая ситуация – скорее исключение.



	Ссылочный тип
Контекст this никак не привязан к функции, даже если она создана в объявлении объекта. Чтобы this передался, нужно вызвать функцию именно через точку (или квадратные скобки).
Любой более хитрый вызов приведёт к потере контекста, например:

	var user = {
	  name: "Вася",
	  hi: function() { alert(this.name); },
	  bye: function() { alert("Пока"); }
	};

	user.hi(); // Вася (простой вызов работает)

	// а теперь вызовем user.hi или user.bye в зависимости от имени
	(user.name == "Вася" ? user.hi : user.bye)(); // undefined // 

В последней строке примера метод получен в результате выполнения тернарного оператора и тут же вызван. Но this при этом теряется.
Если хочется понять, почему, то причина кроется в деталях работы вызова obj.method().

Он ведь, на самом деле, состоит из двух независимых операций: точка . – получение свойства и скобки () – его вызов (предполагается, что это функция).
Функция, как мы говорили раньше, сама по себе не запоминает контекст. Чтобы «донести его» до скобок, JavaScript применяет «финт ушами» – точка возвращает не функцию, а значение специального «ссылочного» типа Reference Type.

Этот тип представляет собой связку «base-name-strict», где:

base – как раз объект,
name – имя свойства,
strict – вспомогательный флаг для передачи use strict.

То есть, ссылочный тип (Reference Type) – это своеобразное «три-в-одном». Он существует исключительно для целей спецификации, мы его не видим, поскольку любой оператор тут же от него избавляется:
	Скобки () получают из base значение свойства name и вызывают в контексте base.

	Другие операторы получают из base значение свойства name и используют, а остальные компоненты игнорируют.

Поэтому любая операция над результатом операции получения свойства, кроме вызова, приводит к потере контекста.
Аналогично работает и получение свойства через квадратные скобки obj[method].




Почему this присваивается именно так?
важность: 3
Вызовы (1) и (2) в примере ниже работают не так, как (3) и (4):

	 "use strict"
	var obj, method;

	obj = {
	  go: function() { alert(this); }
	};

	obj.go();            // (1) object
	(obj.go)();          // (2) object
	(method = obj.go)();      // (3) undefined
	(obj.go || obj.stop)(); // (4) undefined

	решение
1 - Обычный вызов функции в контексте объекта.
2 - То же самое, скобки ни на что не влияют.

3 - Здесь не просто вызов obj.method(), а более сложный вызов вида (выражение).method(). Такой вызов работает, как если бы он был разбит на две строки:

	f = obj.go; // сначала вычислить выражение
	f();             // потом вызвать то, что получилось

При этом f() выполняется как обычная функция, без передачи this.

4 - Здесь также слева от точки находится выражение, вызов аналогичен двум строкам.
В спецификации это объясняется при помощи специального внутреннего типа Reference Type.

Если подробнее – то obj.go() состоит из двух операций:

	1 - Сначала получить свойство obj.go.
	2 - Потом вызвать его как функцию.

Но откуда на шаге 2 получить this? Как раз для этого операция получения свойства obj.go возвращает значение особого типа Reference Type, который в дополнение к свойству go содержит информацию об obj. Далее, на втором шаге, вызов его при помощи скобок () правильно устанавливает this.

Любые другие операции, кроме вызова, превращают Reference Type в обычный тип, в данном случае – функцию go (так уж этот тип устроен).

Поэтому получается, что (method = obj.go) присваивает в переменную method функцию go, уже без всякой информации об объекте obj.
Аналогичная ситуация и в случае (4): оператор ИЛИ || делает из Reference Type обычную функцию.








	Преобразование объектов: toString и valueOf
Ранее, в главе Преобразование типов для примитивов мы рассматривали преобразование типов для примитивов. Теперь добавим в нашу картину мира объекты.
Бывают операции, при которых объект должен быть преобразован в примитив.

Например:
    Строковое преобразование – если объект выводится через alert(obj).
    Численное преобразование – при арифметических операциях, сравнении с примитивом.
    Логическое преобразование – при if(obj) и других логических операциях.
    Рассмотрим эти преобразования по очереди.


    Логическое преобразование
Проще всего – с логическим преобразованием.
Любой объект в логическом контексте – true, даже если это пустой массив [] или объект {}.
    if ({} && []) {
    alert( "Все объекты - true!" ); // alert сработает
    }

    Строковое преобразование
Строковое преобразование проще всего увидеть, если вывести объект при помощи alert:
    var user = {
    firstName: 'Василий'
    };
    alert( user ); // [object Object]

Как видно, содержимое объекта не вывелось. Это потому, что стандартным строковым представлением пользовательского объекта является строка "[object Object]".
Такой вывод объекта не содержит интересной информации. Поэтому имеет смысл его поменять на что-то более полезное.
Если в объекте присутствует метод toString, который возвращает примитив, то он используется для преобразования.

        var user = {
    firstName: 'Василий',
    toString: function() {
        return 'Пользователь ' + this.firstName;
    }
    };
    alert( user );  // Пользователь Василий

Результатом toString может быть любой примитив
Метод toString не обязан возвращать именно строку.
Его результат может быть любого примитивного типа. Например, это может быть число, как в примере ниже:

    var obj = {
    toString: function() {
        return 123;
    }
    };
    alert( obj ); // 123

Поэтому мы и называем его здесь «строковое преобразование», а не «преобразование к строке».
Все объекты, включая встроенные, имеют свои реализации метода toString, например:
    alert( [1, 2] ); // toString для массивов выводит список элементов "1,2"
    alert( new Date ); // toString для дат выводит дату в виде строки
    alert( function() {} ); // toString для функции выводит её код


    Численное преобразование
Для численного преобразования объекта используется метод valueOf, а если его нет – то toString:
    var room = {
    number: 777,
    valueOf: function() { return this.number; },
    toString: function() { return this.number; }
    };
    alert( +room );  // 777, вызвался valueOf
    delete room.valueOf; // valueOf удалён
    alert( +room );  // 777, вызвался toString

Метод valueOf обязан возвращать примитивное значение, иначе его результат будет проигнорирован. При этом – не обязательно числовое.


    У большинства объектов нет valueOf()
У большинства встроенных объектов такого valueOf нет, поэтому численное и строковое преобразования для них работают одинаково.
Исключением является объект Date, который поддерживает оба типа преобразований:
    alert( new Date() ); // toString: Дата в виде читаемой строки
    alert( +new Date() ); // valueOf: кол-во миллисекунд, прошедших с 01.01.1970

    Детали спецификации
Если посмотреть в стандарт, то в пункте 15.2.4.4 говорится о том, что valueOf есть у любых объектов. Но он ничего не делает, просто возвращает сам объект (непримитивное значение!), а потому игнорируется.
Две стадии преобразования
Итак, объект преобразован в примитив при помощи toString или valueOf.
Но на этом преобразования не обязательно заканчиваются. Вполне возможно, что в процессе вычислений этот примитив будет преобразован во что-то другое.
Например, рассмотрим применение к объекту операции ==:
    var obj = {
    valueOf: function() {
        return 1;
    }
    };

    alert( obj == true ); // true

Объект obj был сначала преобразован в примитив, используя численное преобразование, получилось 1 == true.
Далее, так как значения всё ещё разных типов, применяются правила преобразования примитивов, результат: true.
То же самое – при сложении с объектом при помощи +:
    var obj = {
    valueOf: function() {
        return 1;
    }
    };

    alert( obj + "test" ); // 1test

Или вот, для разности объектов:
    var a = {
    valueOf: function() {
        return "1";
    }
    };
    var b = {
    valueOf: function() {
        return "2";
    }
    };

    alert( a + b ); // "12"
    alert( a - b ); // "1" - "2" = -1

Исключение: Date
Объект Date по историческим причинам является исключением.
Бинарный оператор плюс + обычно использует численное преобразование и метод valueOf. Как мы уже знаем, если подходящего valueOf нет (а его нет у большинства объектов), то используется toString, так что в итоге преобразование происходит к строке. Но если есть valueOf, то используется valueOf. Выше в примере как раз a + b это демонстрируют.
У объектов Date есть и valueOf – возвращает количество миллисекунд, и toString – возвращает строку с датой.
…Но оператор + для Date использует именно toString (хотя должен бы valueOf).
Это и есть исключение:
    // бинарный плюс для даты toString, для остальных объектов valueOf
    alert( new Date + "" ); // "строка даты"

Других подобных исключений нет.


    Как испугать Java-разработчика
В языке Java (это не JavaScript, другой язык, здесь приведён для примера) логические значения можно создавать, используя синтаксис new Boolean(true/false), например new Boolean(true).
В JavaScript тоже есть подобная возможность, которая возвращает «объектную обёртку» для логического значения.
Эта возможность давно существует лишь для совместимости, она и не используется на практике, поскольку приводит к странным результатам. Некоторые из них могут сильно удивить человека, не привыкшего к JavaScript, например:
    var value = new Boolean(false);
    if (value) {
    alert( true ); // сработает!
    }

Почему запустился alert? Ведь в if находится false… Проверим:
    var value = new Boolean(false);
    alert( value ); // выводит false, все ок..
    if (value) {
    alert( true ); // ..но тогда почему выполняется alert в if ?!?
    }

Дело в том, что new Boolean – это не примитивное значение, а объект. Поэтому в логическом контексте он преобразуется к true, в результате работает первый пример.
А второй пример вызывает alert, который преобразует объект к строке, и он становится "false".
В JavaScript вызовы new Boolean/String/Number не используются, а используются простые вызовы соответствующих функций, они преобразуют значение в примитив нужного типа, например Boolean(val) === !!val.


Итого
    В логическом контексте объект – всегда true.
    При строковом преобразовании объекта используется его метод toString. Он должен возвращать примитивное значение, причём не обязательно именно строку.
    Для численного преобразования используется метод valueOf, который также может возвратить любое примитивное значение. У большинства объектов valueOf не работает (возвращает сам объект и потому игнорируется), при этом для численного преобразования используется toString.
    Полный алгоритм преобразований есть в спецификации ECMAScript, смотрите пункты 11.8.5, 11.9.3, а также 9.1 и 9.3.

Заметим, для полноты картины, что некоторые тесты знаний в интернет предлагают вопросы типа:

    {}[0]  // чему равно?
    {} + {} // а так?
Если вы запустите эти выражения в консоли, то результат может показаться странным. Подвох здесь в том, что если фигурные скобки {...} идут не в выражении, а в основном потоке кода, то JavaScript считает, что это не объект, а «блок кода» (как if, for, но без оператора просто группировка команд вместе используется редко).
Вот блок кода с командой:

    {
    alert("Блок")
    }

А если команду изъять, то будет пустой блок {}, который ничего не делает. Два примера выше как раз содержат пустой блок в начале, который ничего не делает. Иначе говоря:
    {}[0]   // то же что и: [0]
    {} + {} // то же что и: + {}
То есть, такие вопросы – не на преобразование типов, а на понимание, что если { ... } находится вне выражений, то это не объект, а блок.






    Создание объектов через "new"
Обычный синтаксис {...} позволяет создать один объект. Но зачастую нужно создать много однотипных объектов.
Для этого используют «функции-конструкторы», запуская их при помощи специального оператора new.
Конструктор
Конструктором становится любая функция, вызванная через new.

Например:
    function Animal(name) {
    this.name = name;
    this.canWalk = true;
    }

    var animal = new Animal("ёжик");

Заметим, что, технически, любая функция может быть использована как конструктор. То есть, любую функцию можно вызвать при помощи new. Как-то особым образом указывать, что она – конструктор – не надо.
Но, чтобы выделить функции, задуманные как конструкторы, их называют с большой буквы: Animal, а не animal.
Детальнее – функция, запущенная через new, делает следующее:
1 - Создаётся новый пустой объект.
2 - Ключевое слово this получает ссылку на этот объект.
Функция выполняется. Как правило, она модифицирует this (т.е. этот новый объект), добавляет методы, свойства.
Возвращается this.
В результате вызова new Animal("ёжик"); получаем такой объект:
    animal = {
    name: "ёжик",
    canWalk: true
    }

Иными словами, при вызове new Animal происходит что-то в таком духе (первая и последняя строка – это то, что делает интерпретатор):

    function Animal(name) {
    // this = {};

    // в this пишем свойства, методы
    this.name = name;
    this.canWalk = true;

    // return this;
    }

Теперь многократными вызовами new Animal с разными параметрами мы можем создать столько объектов, сколько нужно. Поэтому такую функцию и называют конструктором – она предназначена для «конструирования» объектов.

    new function() { … }
Иногда функцию-конструктор объявляют и тут же используют, вот так:

    var animal = new function() {
    this.name = "Васька";
    this.canWalk = true;
    };

Так делают, когда хотят создать единственный объект данного типа. Пример выше с тем же успехом можно было бы переписать как:
    var animal = {
    name: "Васька",
    canWalk: true
    }

…Но обычный синтаксис {...} не подходит, когда при создании свойств объекта нужны более сложные вычисления. Их можно проделать в функции-конструкторе и записать результат в this.
    
    Правила обработки return
Как правило, конструкторы ничего не возвращают. Их задача – записать всё, что нужно, в this, который автоматически станет результатом.
Но если явный вызов return всё же есть, то применяется простое правило:
1 - При вызове return с объектом, будет возвращён он, а не this.
2 - При вызове return с примитивным значением, оно будет отброшено.
Иными словами, вызов return с объектом вернёт объект, а с чем угодно, кроме объекта – возвратит, как обычно, this.
Например, возврат объекта:

    function BigAnimal() {
    this.name = "Мышь";
    return { name: "Годзилла" };  // <-- возвратим объект
    }
    alert( new BigAnimal().name );  // Годзилла, получили объект вместо this

А вот пример с возвратом строки:

    function BigAnimal() {
    this.name = "Мышь";
    return "Годзилла"; // <-- возвратим примитив
    }
    alert( new BigAnimal().name ); // Мышь, получили this (а Годзилла пропал)

Эта особенность работы new прописана в стандарте, но используется она весьма редко.


    Можно без скобок
Кстати, при вызове new без аргументов скобки можно не ставить:
    var animal = new BigAnimal; // <-- без скобок
    // то же самое что
    var animal = new BigAnimal();
Не сказать, что выбрасывание скобок – «хороший стиль», но такой синтаксис допустим стандартом.
    
    Создание методов в конструкторе
Использование функций для создания объекта дает большую гибкость. Можно передавать конструктору параметры, определяющие как его создавать, и он будет «клепать» объекты заданным образом.
Добавим в создаваемый объект ещё и метод.
Например, new User(name) создает объект с заданным значением свойства name и методом sayHi:
 
    function User(name) {
    this.name = name;

    this.sayHi = function() {
        alert( "Моё имя: " + this.name );
    };
    }

    var ivan = new User("Иван");

    ivan.sayHi(); // Моё имя: Иван

    /*
    ivan = {
    name: "Иван",
    sayHi: функция
    }
    */

    Локальные переменные
В функции-конструкторе бывает удобно объявить вспомогательные локальные переменные и вложенные функции, которые будут видны только внутри:
 
    function User(firstName, lastName) {
    // вспомогательная переменная
    var phrase = "Привет";

    //  вспомогательная вложенная функция
    function getFullName() {
        return firstName + " " + lastName;
        }

    this.sayHi = function() {
        alert( phrase + ", " + getFullName() ); // использование
    };
    }

    var vasya = new User("Вася", "Петров");
    vasya.sayHi(); // Привет, Вася Петров

Мы уже говорили об этом подходе ранее, в главе Локальные переменные для объекта.
Те функции и данные, которые должны быть доступны для внешнего кода, мы пишем в this – и к ним можно будет обращаться, как например vasya.sayHi(), а вспомогательные, которые нужны только внутри самого объекта, сохраняем в локальной области видимости.

    Итого
Объекты могут быть созданы при помощи функций-конструкторов:
Любая функция может быть вызвана с new, при этом она получает новый пустой объект в качестве this, в который она добавляет свойства. Если функция не решит возвратить свой объект, то её результатом будет this.
Функции, которые предназначены для создания объектов, называются конструкторами. Их названия пишут с большой буквы, чтобы отличать от обычных.








    Дескрипторы, геттеры и сеттеры свойств
В этой главе мы рассмотрим возможности, которые позволяют очень гибко и мощно управлять всеми свойствами объекта, включая их аспекты – изменяемость, видимость в цикле for..in и даже незаметно делать их функциями.
Они поддерживаются всеми современными браузерами, но не IE8-. Впрочем, даже IE8 их поддерживает, но только для DOM-объектов (используются при работе со страницей, это сейчас вне нашего рассмотрения).

    Дескрипторы в примерах
Основной метод для управления свойствами – Object.defineProperty.
Он позволяет объявить свойство объекта и, что самое главное, тонко настроить его особые аспекты, которые никак иначе не изменить.
Синтаксис:
    Object.defineProperty(obj, prop, descriptor)
Аргументы:
    obj - Объект, в котором объявляется свойство.
    prop - Имя свойства, которое нужно объявить или модифицировать.
    descriptor - Дескриптор – объект, который описывает поведение свойства.

В нём могут быть следующие поля:
    value – значение свойства, по умолчанию undefined
    writable – значение свойства можно менять, если true. По умолчанию false.
    configurable – если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty. По умолчанию false.
    enumerable – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false.
    get – функция, которая возвращает значение свойства. По умолчанию undefined.
    set – функция, которая записывает значение свойства. По умолчанию undefined.
Чтобы избежать конфликта, запрещено одновременно указывать значение value и функции get/set. Либо значение, либо функции для его чтения-записи, одно из двух. Также запрещено и не имеет смысла указывать writable при наличии get/set-функций.

Далее мы подробно разберём эти свойства на примерах.

    Обычное свойство
Два таких вызова работают одинаково:

    var user = {};
    // 1. простое присваивание
    user.name = "Вася";
    // 2. указание значения через дескриптор
    Object.defineProperty(user, "name", { value: "Вася", configurable: true, writable: true, enumerable: true });
    Оба вызова выше добавляют в объект user обычное (удаляемое, изменяемое, перечисляемое) свойство.


    Свойство-константа
Для того, чтобы сделать свойство неизменяемым, изменим его флаги writable и configurable:

    "use strict";

    var user = {};

    Object.defineProperty(user, "name", {
    value: "Вася",
    writable: false, // запретить присвоение "user.name="
    configurable: false // запретить удаление "delete user.name"
    });

    // Теперь попытаемся изменить это свойство.

    // в strict mode присвоение "user.name=" вызовет ошибку
    user.name = "Петя";

Заметим, что без use strict операция записи «молча» не сработает. Лишь если установлен режим use strict, то дополнительно сгенерируется ошибка.
    
    Свойство, скрытое для for…in
Встроенный метод toString, как и большинство встроенных методов, не участвует в цикле for..in. Это удобно, так как обычно такое свойство является «служебным».
К сожалению, свойство toString, объявленное обычным способом, будет видно в цикле for..in, например:
 
    var user = {
    name: "Вася",
    toString: function() { return this.name; }
    };

    for(var key in user) alert(key);  // name, toString

Мы бы хотели, чтобы поведение нашего метода toString было таким же, как и стандартного.
Object.defineProperty может исключить toString из списка итерации, поставив ему флаг enumerable: false. 
По стандарту, у встроенного toString этот флаг уже стоит.

    var user = {
    name: "Вася",
    toString: function() { return this.name; }
    };

    // помечаем toString как не подлежащий перебору в for..in
    Object.defineProperty(user, "toString", {enumerable: false});

    for(var key in user) alert(key);  // name

Обратим внимание, вызов defineProperty не перезаписал свойство, а просто модифицировал настройки у существующего toString.


    Свойство-функция
Дескриптор позволяет задать свойство, которое на самом деле работает как функция. Для этого в нём нужно указать эту функцию в get.
Например, у объекта user есть обычные свойства: имя firstName и фамилия surname.
Создадим свойство fullName, которое на самом деле является функцией:

    var user = {
    firstName: "Вася",
    surname: "Петров"
    }

    Object.defineProperty(user, "fullName", {
    get: function() {
        return this.firstName + ' ' + this.surname;
    }
    });

    alert(user.fullName); // Вася Петров

Обратим внимание, снаружи fullName – это обычное свойство user.fullName. Но дескриптор указывает, что на самом деле его значение возвращается функцией.
Также можно указать функцию, которая используется для записи значения, при помощи дескриптора set.
Например, добавим возможность присвоения user.fullName к примеру выше:

    var user = {
    firstName: "Вася",
    surname: "Петров"
    }

    Object.defineProperty(user, "fullName", {

    get: function() {
        return this.firstName + ' ' + this.surname;
    },

    set: function(value) {
        var split = value.split(' ');
        this.firstName = split[0];
        this.surname = split[1];
        }
    });

    user.fullName = "Петя Иванов";
    alert( user.firstName ); // Петя
    alert( user.surname ); // Иванов

    Указание get/set в литералах
Если мы создаём объект при помощи синтаксиса { ... }, то задать свойства-функции можно прямо в его определении.
Для этого используется особый синтаксис: get свойство или set свойство.
Например, ниже объявлен геттер-сеттер fullName:

    var user = {
    firstName: "Вася",
    surname: "Петров",

    get fullName() {
        return this.firstName + ' ' + this.surname;
    },

    set fullName(value) {
        var split = value.split(' ');
        this.firstName = split[0];
        this.surname = split[1];
    }
    };

    alert( user.fullName ); // Вася Петров (из геттера)

    user.fullName = "Петя Иванов";
    alert( user.firstName ); // Петя  (поставил сеттер)
    alert( user.surname ); // Иванов (поставил сеттер)

    Да здравствуют get/set!
Казалось бы, зачем нам назначать get/set для свойства через всякие хитрые вызовы, когда можно сделать просто функции с самого начала? Например, getFullName, setFullName…
Конечно, в ряде случаев свойства выглядят короче, такое решение просто может быть красивым. Но основной бонус – это гибкость, возможность получить контроль над свойством в любой момент!
Например, в начале разработки мы используем обычные свойства, например у User будет имя name и возраст age:

    function User(name, age) {
    this.name = name;
    this.age = age;
    }

    var pete = new User("Петя", 25);

    alert( pete.age ); // 25

С обычными свойствами в коде меньше букв, они удобны, причины использовать функции пока нет.
…Но рано или поздно могут произойти изменения. Например, в User может стать более целесообразно вместо возраста age хранить дату рождения birthday:

    function User(name, birthday) {
    this.name = name;
    this.birthday = birthday;
    }

    var pete = new User("Петя", new Date(1987, 6, 1));

Что теперь делать со старым кодом, который выводит свойство age?
Можно, конечно, найти все места и поправить их, но это долго, а иногда и невозможно, скажем, если вы взаимодействуете со сторонней библиотекой, код в которой – чужой и влезать в него нежелательно.
Добавление get-функции age позволяет обойти проблему легко и непринуждённо:

    function User(name, birthday) {
    this.name = name;
    this.birthday = birthday;

    // age будет высчитывать возраст по birthday
    Object.defineProperty(this, "age", {
        get: function() {
        var today = new Date();
        var yearDelta = today.getFullYear() - this.birthday.getFullYear();

        if (today.getMonth() > this.birthday.getMonth() ||
            (today.getMonth() === this.birthday.getMonth() && today.getDate() >= this.birthday.getDate())) {
            return yearDelta;
        }

        return yearDelta - 1;
        }
    });
    }

    var pete = new User("Петя", new Date(1987, 6, 1));

    alert( pete.birthday ); // и дата рождения доступна
    alert( pete.age );      // и возраст

Заметим, что pete.age снаружи как было свойством, так и осталось. То есть, переписывать внешний код на вызов функции pete.age() не нужно.
Таким образом, defineProperty позволяет нам начать с обычных свойств, а в будущем, при необходимости, можно в любой момент заменить их на функции, реализующие более сложную логику.

    Другие методы работы со свойствами
Object.defineProperties(obj, descriptors) - Позволяет объявить несколько свойств сразу:

    var user = {}

    Object.defineProperties(user, {
    firstName: {
        value: "Петя"
    },

    surname: {
        value: "Иванов"
    },

    fullName: {
        get: function() {
        return this.firstName + ' ' + this.surname;
        }
    }
    });

    alert( user.fullName ); // Петя Иванов

Object.keys(obj), Object.getOwnPropertyNames(obj) - Возвращают массив – список свойств объекта.

Object.keys - возвращает только enumerable-свойства.

Object.getOwnPropertyNames – возвращает все:

    var obj = {
    a: 1,
    b: 2,
    internal: 3
    };

    Object.defineProperty(obj, "internal", {
    enumerable: false
    });

    alert( Object.keys(obj) ); // a,b
    alert( Object.getOwnPropertyNames(obj) ); // a, b, internal
    
Object.getOwnPropertyDescriptor(obj, prop) - Возвращает дескриптор для свойства obj[prop].Полученный дескриптор можно изменить и использовать defineProperty для сохранения изменений, например:

    var obj = {
    test: 5
    };
    var descriptor = Object.getOwnPropertyDescriptor(obj, 'test');

    // заменим value на геттер, для этого...
    delete descriptor.value; // ..нужно убрать value/writable
    delete descriptor.writable;
    descriptor.get = function() { // и поставить get
    alert( "Preved :)" );
    };

    // поставим новое свойство вместо старого

    // если не удалить - defineProperty объединит старый дескриптор с новым
    delete obj.test;

    Object.defineProperty(obj, 'test', descriptor);

    obj.test; // Preved :)



…И несколько методов, которые используются очень редко:

Object.preventExtensions(obj) - Запрещает добавление свойств в объект.
Object.seal(obj) - Запрещает добавление и удаление свойств, все текущие свойства делает configurable: false.
Object.freeze(obj) - Запрещает добавление, удаление и изменение свойств, все текущие свойства делает configurable: false, writable: false.
Object.isExtensible(obj) - Возвращает false, если добавление свойств объекта было запрещено вызовом метода Object.preventExtensions.
Object.isSealed(obj) - Возвращает true, если добавление и удаление свойств объекта запрещено, и все текущие свойства являются configurable: false.
Object.isFrozen(obj) - Возвращает true, если добавление, удаление и изменение свойств объекта запрещено, и все текущие свойства являются configurable: false, writable: false.











    Статические и фабричные методы
Методы и свойства, которые не привязаны к конкретному экземпляру объекта, называют «статическими». Их записывают прямо в саму функцию-конструктор.

    Статические свойства
В коде ниже используются статические свойства Article.count и Article.DEFAULT_FORMAT:

    function Article() {
    Article.count++;
    }

    Article.count = 0; // статическое свойство-переменная
    Article.DEFAULT_FORMAT = "html"; // статическое свойство-константа

Они хранят данные, специфичные не для одного объекта, а для всех статей целиком.
Как правило, это чаще константы, такие как формат «по умолчанию» Article.DEFAULT_FORMAT.

    Статические методы
С примерами статических методов мы уже знакомы: это встроенные методы String.fromCharCode, Date.parse.
Создадим для Article статический метод Article.showCount():
 
    function Article() {
    Article.count++;

    //...
    }
    Article.count = 0;

    Article.showCount = function() {
    alert( this.count ); // (1)
    }

    // использование
    new Article();
    new Article();
    Article.showCount(); // (2)

Здесь Article.count – статическое свойство, а Article.showCount – статический метод.
Обратим внимание на использование this в примере выше. Несмотря на то, что переменная и метод – статические, он всё ещё полезен. В строке (1) он равен Article.
    
    Пример: сравнение объектов
Ещё один хороший способ применения – сравнение объектов.
Например, у нас есть объект Journal для журналов. Журналы можно сравнивать – по толщине, по весу, по другим параметрам.
Объявим «стандартную» функцию сравнения, которая будет сравнивать по дате издания. Эта функция сравнения, естественно, не привязана к конкретному журналу, но относится к журналам вообще.
Поэтому зададим её как статический метод Journal.compare:

    function Journal(date) {
    this.date = date;
    // ...
    }

    // возвращает значение, большее 0, если A больше B, иначе меньшее 0
    Journal.compare = function(journalA, journalB) {
    return journalA.date - journalB.date;
    };

В примере ниже эта функция используется для поиска самого раннего журнала из массива:

    function Journal(date) {
    this.date = date;

    this.formatDate = function(date) {
        return date.getDate() + '.' + (date.getMonth() + 1) + '.' + date.getFullYear();
    };

    this.getTitle = function() {
        return "Выпуск от " + this.formatDate(this.date);
    };

    }

    Journal.compare = function(journalA, journalB) {
    return journalA.date - journalB.date;
    };

    // использование:
    var journals = [
    new Journal(new Date(2012, 1, 1)),
    new Journal(new Date(2012, 0, 1)),
    new Journal(new Date(2011, 11, 1))
    ];

    function findMin(journals) {
    var min = 0;
    for (var i = 0; i < journals.length; i++) {
        // используем статический метод
        if (Journal.compare(journals[min], journals[i]) > 0) min = i;
    }
    return journals[min];
    }

    alert( findMin(journals).getTitle() );

Статический метод также можно использовать для функций, которые вообще не требуют наличия объекта.
Например, метод formatDate(date) можно сделать статическим. Он будет форматировать дату «как это принято в журналах», при этом его можно использовать в любом месте кода, не обязательно создавать журнал.
Например:

    function Journal() { /*...*/ }

    Journal.formatDate = function(date) {
    return date.getDate() + '.' + (date.getMonth()+1) + '.' + date.getFullYear();
    }

    // ни одного объекта Journal нет, просто форматируем дату
    alert( Journal.formatDate(new Date) );


    Фабричные методы
Рассмотрим ситуацию, когда объект нужно создавать различными способами. Например, это реализовано во встроенном объекте Date. Он по-разному обрабатывает аргументы разных типов:
new Date() – создаёт объект с текущей датой,
new Date(milliseconds) – создаёт дату по количеству миллисекунд milliseconds,
new Date(year, month, day ...) – создаёт дату по компонентам год, месяц, день…
new Date(datestring) – читает дату из строки datestring
"Фабричный статический метод" – удобная альтернатива такому конструктору. Так называется статический метод, который служит для создания новых объектов (поэтому и называется «фабричным»).

Пример встроенного фабричного метода – String.fromCharCode(code). Этот метод создает строку из кода символа:
    var str = String.fromCharCode(65);
    alert( str ); // 'A'

Но строки – слишком простой пример, посмотрим что-нибудь посложнее.
Допустим, нам нужно создавать объекты User: анонимные new User() и с данными new User({name: 'Вася', age: 25}).
Можно, конечно, создать полиморфную функцию-конструктор User:

    function User(userData) {
    if (userData) { // если указаны данные -- одна ветка if
        this.name = userData.name;
        this.age = userData.age;
    } else { // если не указаны -- другая
        this.name = 'Аноним';
    }

    this.sayHi = function() {
        alert(this.name)
    };
    // ...
    }

    // Использование

    var guest = new User();
    guest.sayHi(); // Аноним

    var knownUser = new User({
    name: 'Вася',
    age: 25
    });
    knownUser.sayHi(); // Вася

Подход с использованием фабричных методов был бы другим. Вместо разбора параметров в конструкторе – делаем два метода: User.createAnonymous и User.createFromData.
Код:

    function User() {
    this.sayHi = function() {
        alert(this.name)
    };
    }

    User.createAnonymous = function() {
    var user = new User;
    user.name = 'Аноним';
    return user;
    }

    User.createFromData = function(userData) {
    var user = new User;
    user.name = userData.name;
    user.age = userData.age;
    return user;
    }

    // Использование

    var guest = User.createAnonymous();
    guest.sayHi(); // Аноним

    var knownUser = User.createFromData({
    name: 'Вася',
    age: 25
    });
    knownUser.sayHi(); // Вася

Преимущества использования фабричных методов:
Лучшая читаемость кода. Как конструктора – вместо одной большой функции несколько маленьких, так и вызывающего кода – явно видно, что именно создаётся.
Лучший контроль ошибок, т.к. если в createFromData ничего не передали, то будет ошибка, а полиморфный конструктор создал бы анонимного посетителя.
Удобная расширяемость. Например, нужно добавить создание администратора, без аргументов. Фабричный метод сделать легко: User.createAdmin = function() { ... }. А для полиморфного конструктора вызов без аргумента создаст анонима, так что нужно добавить параметр – «тип посетителя» и усложнить этим код.
Поэтому полиморфные конструкторы лучше использовать там, где нужен именно полиморфизм, т.е. когда непонятно, какого типа аргумент передадут, и хочется в одном конструкторе охватить все варианты.
 А в остальных случаях отличная альтернатива – фабричные методы.


    Итого
Статические свойства и методы объекта удобно применять в следующих случаях:
Общие действия и подсчёты, имеющие отношения ко всем объектам данного типа. В примерах выше это подсчёт количества.
Методы, не привязанные к конкретному объекту, например сравнение.
Вспомогательные методы, которые полезны вне объекта, например для форматирования даты.
Фабричные методы.















    Явное указание this: "call", "apply"
Итак, мы знаем, что this – это текущий объект при вызове «через точку» и новый объект при конструировании через new.
В этой главе наша цель получить окончательное и полное понимание this в JavaScript. Для этого не хватает всего одного элемента: способа явно указать this при помощи методов call и apply.

    Метод call
Синтаксис метода call:
    func.call(context, arg1, arg2, ...)
При этом вызывается функция func, первый аргумент call становится её this, а остальные передаются «как есть».
Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), но с явно указанным this(=context).
Например, у нас есть функция showFullName, которая работает с this:

    function showFullName() {
    alert( this.firstName + " " + this.lastName );
    }

Пока объекта нет, но это нормально, ведь JavaScript позволяет использовать this везде. Любая функция может в своём коде упомянуть this, каким будет это значение – выяснится в момент запуска.
Вызов showFullName.call(user) запустит функцию, установив this = user, вот так:
 
    function showFullName() {
    alert( this.firstName + " " + this.lastName );
    }

    var user = {
    firstName: "Василий",
    lastName: "Петров"
    };

    // функция вызовется с this=user
    showFullName.call(user) // "Василий Петров"

После контекста в call можно передать аргументы для функции. Вот пример с более сложным вариантом showFullName, который конструирует ответ из указанных свойств объекта:

    var user = {
    firstName: "Василий",
    surname: "Петров",
    patronym: "Иванович"
    };

    function showFullName(firstPart, lastPart) {
    alert( this[firstPart] + " " + this[lastPart] );
    }

    // f.call(контекст, аргумент1, аргумент2, ...)
    showFullName.call(user, 'firstName', 'surname') // "Василий Петров"
    showFullName.call(user, 'firstName', 'patronym') // "Василий Иванович"


    «Одалживание метода»
При помощи call можно легко взять метод одного объекта, в том числе встроенного, и вызвать в контексте другого.
Это называется «одалживание метода» (на англ. method borrowing).
Используем эту технику для упрощения манипуляций с arguments.
Как мы знаем, arguments не массив, а обычный объект, поэтому таких полезных методов как push, pop, join и других у него нет. Но иногда так хочется, чтобы были…
Нет ничего проще! Давайте скопируем метод join из обычного массива:

    function printArgs() {
    arguments.join = [].join; // одолжили метод (1)

    var argStr = arguments.join(':'); // (2)

    alert( argStr ); // сработает и выведет 1:2:3
    }

    printArgs(1, 2, 3);

В строке (1) объявлен пустой массив [] и скопирован его метод [].join. Обратим внимание, мы не вызываем его, а просто копируем. Функция, в том числе встроенная – обычное значение, мы можем скопировать любое свойство любого объекта, и [].join здесь не исключение.
В строке (2) запустили join в контексте arguments, как будто он всегда там был.

    Почему вызов сработает?
Здесь метод join массива скопирован и вызван в контексте arguments. Не произойдёт ли что-то плохое от того, что arguments – не массив? Почему он, вообще, сработал?
Ответ на эти вопросы простой. В соответствии со спецификацией, внутри join реализован примерно так:

    function join(separator) {
    if (!this.length) return '';

    var str = this[0];

    for (var i = 1; i < this.length; i++) {
        str += separator + this[i];
    }

    return str;
    }

Как видно, используется this, числовые индексы и свойство length. Если эти свойства есть, то все в порядке. А больше ничего и не нужно.
В качестве this подойдёт даже обычный объект:
 
    var obj = { // обычный объект с числовыми индексами и length
    0: "А",
    1: "Б",
    2: "В",
    length: 3
    };

    obj.join = [].join;
    alert( obj.join(';') ); // "A;Б;В"

…Однако, копирование метода из одного объекта в другой не всегда приемлемо!
Представим на минуту, что вместо arguments у нас – произвольный объект. У него тоже есть числовые индексы, length и мы хотим вызвать в его контексте метод [].join. То есть, ситуация похожа на arguments, но (!) вполне возможно, что у объекта есть свой метод join.
Поэтому копировать [].join, как сделано выше, нельзя: если он перезапишет собственный join объекта, то будет страшный бардак и путаница.
Безопасно вызвать метод нам поможет call:
 
    function printArgs() {
    var join = [].join; // скопируем ссылку на функцию в переменную

    // вызовем join с this=arguments,
    // этот вызов эквивалентен arguments.join(':') из примера выше
    var argStr = join.call(arguments, ':');

    alert( argStr ); // сработает и выведет 1:2:3
    }

    printArgs(1, 2, 3);

Мы вызвали метод без копирования. Чисто, безопасно.


Ещё пример: [].slice.call(arguments)
В JavaScript есть очень простой способ сделать из arguments настоящий массив. Для этого возьмём метод массива: slice.
По стандарту вызов arr.slice(start, end) создаёт новый массив и копирует в него элементы массива arr от start до end. А если start и end не указаны, то копирует весь массив.
Вызовем его в контексте arguments:

    function printArgs() {
    // вызов arr.slice() скопирует все элементы из this в новый массив
    var args = [].slice.call(arguments);
    alert( args.join(', ') ); // args - полноценный массив из аргументов
    }

    printArgs('Привет', 'мой', 'мир'); // Привет, мой, мир

Как и в случае с join, такой вызов технически возможен потому, что slice для работы требует только нумерованные свойства и length. Всё это в arguments есть.

    
    Метод apply
Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply.
Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.

    func.call(context, arg1, arg2);
    // идентичен вызову
    func.apply(context, [arg1, arg2]);
    В частности, эти две строчки сработают одинаково:

    showFullName.call(user, 'firstName', 'surname');

    showFullName.apply(user, ['firstName', 'surname']);

Преимущество apply перед call отчётливо видно, когда мы формируем массив аргументов динамически.
Например, в JavaScript есть встроенная функция Math.max(a, b, c...), которая возвращает максимальное значение из аргументов:

     alert( Math.max(1, 5, 2) ); // 5
При помощи apply мы могли бы найти максимум в произвольном массиве, вот так:

    var arr = [];
    arr.push(1);
    arr.push(5);
    arr.push(2);

    // получить максимум из элементов arr
    alert( Math.max.apply(null, arr) ); // 5

В примере выше мы передали аргументы через массив – второй параметр apply… Но вы, наверное, заметили небольшую странность? В качестве контекста this был передан null.
Строго говоря, полным эквивалентом вызову Math.max(1,2,3) был бы вызов Math.max.apply(Math, [1,2,3]). В обоих этих вызовах контекстом будет объект Math.
Но в данном случае в качестве контекста можно передавать что угодно, поскольку в своей внутренней реализации метод Math.max не использует this. Действительно, зачем this, если нужно всего лишь выбрать максимальный из аргументов? Вот так, при помощи apply мы получили короткий и элегантный способ вычислить максимальное значение в массиве!

    Вызов call/apply с null или undefined
В современном стандарте call/apply передают this «как есть». А в старом, без use strict, при указании первого аргумента null или undefined в call/apply, функция получает this = window, например:
Современный стандарт:

    function f() {
    "use strict";
    alert( this ); // null
    }

    f.call(null);
    Без use strict:

    function f() {
    alert( this ); // window
    }

    f.call(null);


    Итого про this
Значение this устанавливается в зависимости от того, как вызвана функция:
При вызове функции как метода:
    obj.func(...)    // this = obj
    obj["func"](...)
При обычном вызове:
    func(...) // this = window (ES3) /undefined (ES5)
В new:
    new func() // this = {} (новый объект)
Явное указание:
    func.apply(context, args) // this = context (явная передача)
    func.call(context, arg1, arg2, ...)












Привязка контекста и карринг: "bind"
Функции в JavaScript никак не привязаны к своему контексту this, с одной стороны, здорово – это позволяет быть максимально гибкими, одалживать методы и так далее.
Но с другой стороны – в некоторых случаях контекст может быть потерян. То есть мы вроде как вызываем метод объекта, а на самом деле он получает this = undefined.
Такая ситуация является типичной для начинающих разработчиков, но бывает и у «зубров» тоже. Конечно, «зубры» при этом знают, что с ней делать.

    Пример потери контекста
В браузере есть встроенная функция setTimeout(func, ms), которая вызывает выполнение функции func через ms миллисекунд (=1/1000 секунды).
Мы подробно остановимся на ней и её тонкостях позже, в главе setTimeout и setInterval, а пока просто посмотрим пример.
Этот код выведет «Привет» через 1000 мс, то есть 1 секунду:

    setTimeout(function() {
    alert( "Привет" );
    }, 1000);

Попробуем сделать то же самое с методом объекта, следующий код должен выводить имя пользователя через 1 секунду:

    var user = {
    firstName: "Вася",
    sayHi: function() {
        alert( this.firstName );
    }
    };

    setTimeout(user.sayHi, 1000); // undefined (не Вася!)

При запуске кода выше через секунду выводится вовсе не "Вася", а undefined!
Это произошло потому, что в примере выше setTimeout получил функцию user.sayHi, но не её контекст. То есть, последняя строчка аналогична двум таким:

    var f = user.sayHi;
    setTimeout(f, 1000); // контекст user потеряли

Ситуация довольно типична – мы хотим передать метод объекта куда-то в другое место кода, откуда он потом может быть вызван. Как бы прикрепить к нему контекст, желательно, с минимумом плясок с бубном и при этом надёжно?
Есть несколько способов решения, среди которых мы, в зависимости от ситуации, можем выбирать.

    Решение 1: сделать обёртку
Самый простой вариант решения – это обернуть вызов в анонимную функцию:

    var user = {
    firstName: "Вася",
    sayHi: function() {
        alert( this.firstName );
    }
    };

    setTimeout(function() {
    user.sayHi(); // Вася
    }, 1000);

Теперь код работает, так как user достаётся из замыкания.
Это решение также позволяет передать дополнительные аргументы:
 
    var user = {
    firstName: "Вася",
    sayHi: function(who) {
        alert( this.firstName + ": Привет, " + who );
    }
    };

    setTimeout(function() {
    user.sayHi("Петя"); // Вася: Привет, Петя
    }, 1000);

Но тут же появляется и уязвимое место в структуре кода!
А что, если до срабатывания setTimeout (ведь есть целая секунда) в переменную user будет записано другое значение? К примеру, в другом месте кода будет присвоено user=(другой пользователь)… В этом случае вызов неожиданно будет совсем не тот!
Хорошо бы гарантировать правильность контекста.

    Решение 2: bind для привязки контекста
Напишем вспомогательную функцию bind(func, context), которая будет жёстко фиксировать контекст для func:

    function bind(func, context) {
    return function() { // (*)
        return func.apply(context, arguments);
    };
    }

Посмотрим, что она делает, как работает, на таком примере:

    function f() {
    alert( this );
    }

    var g = bind(f, "Context");
    g(); // Context

То есть, bind(f, "Context") привязывает "Context" в качестве this для f.
Посмотрим, за счёт чего это происходит.
Результатом bind(f, "Context"), как видно из кода, будет анонимная функция (*).
Вот она отдельно:

    function() { // (*)
    return func.apply(context, arguments);
    };
    
Если подставить наши конкретные аргументы, то есть f и "Context", то получится так:

    function() { // (*)
    return f.apply("Context", arguments);
    };

Эта функция запишется в переменную g.
Далее, если вызвать g, то вызов будет передан в f, причём f.apply("Context", arguments) передаст в качестве контекста "Context", который и будет выведен.
Если вызвать g с аргументами, то также будет работать:

    function f(a, b) {
    alert( this );
    alert( a + b );
    }

    var g = bind(f, "Context");
    g(1, 2); // Context, затем 3

Аргументы, которые получила g(...), передаются в f также благодаря методу .apply.
Иными словами, в результате вызова bind(func, context) мы получаем «функцию-обёртку», которая прозрачно передаёт вызов в func, с теми же аргументами, но фиксированным контекстом context.
Вернёмся к user.sayHi. Вариант с bind:

    function bind(func, context) {
    return function() {
        return func.apply(context, arguments);
    };
    }

    var user = {
    firstName: "Вася",
    sayHi: function() {
        alert( this.firstName );
    }
    };

    setTimeout(bind(user.sayHi, user), 1000);

Теперь всё в порядке!
Вызов bind(user.sayHi, user) возвращает такую функцию-обёртку, которая привязывает user.sayHi к контексту user. Она будет вызвана через 1000 мс.
Полученную обёртку можно вызвать и с аргументами – они пойдут в user.sayHi без изменений, фиксирован лишь контекст.
 
    var user = {
    firstName: "Вася",
    sayHi: function(who) { // здесь у sayHi есть один аргумент
        alert( this.firstName + ": Привет, " + who );
    }
    };

    var sayHi = bind(user.sayHi, user);

    // контекст Вася, а аргумент передаётся "как есть"
    sayHi("Петя"); // Вася: Привет, Петя
    sayHi("Маша"); // Вася: Привет, Маша

В примере выше продемонстрирована другая частая цель использования bind – «привязать» функцию к контексту, чтобы в дальнейшем «не таскать за собой» объект, а просто вызывать sayHi.
Результат bind можно передавать в любое место кода, вызывать как обычную функцию, он «помнит» свой контекст.

Решение 3: встроенный метод bind
В современном JavaScript (или при подключении библиотеки es5-shim для IE8-) у функций уже есть встроенный метод bind, который мы можем использовать.
Он работает примерно так же, как bind, который описан выше.
Изменения очень небольшие:

    function f(a, b) {
    alert( this );
    alert( a + b );
    }

    // вместо
    // var g = bind(f, "Context");
    var g = f.bind("Context");
    g(1, 2); // Context, затем 3


    Синтаксис встроенного bind:
var wrapper = func.bind(context[, arg1, arg2...])
func - Произвольная функция
context - Контекст, который привязывается к func
arg1, arg2, …  - Если указаны аргументы arg1, arg2... – они будут прибавлены к каждому вызову новой функции, причем встанут перед теми, которые указаны при вызове.
Результат вызова func.bind(context) аналогичен вызову bind(func, context), описанному выше. То есть, wrapper – это обёртка, фиксирующая контекст и передающая вызовы в func. Также можно указать аргументы, тогда и они будут фиксированы, но об этом чуть позже.

Пример со встроенным методом bind:

    var user = {
    firstName: "Вася",
    sayHi: function() {
        alert( this.firstName );
    }
    };

    // setTimeout( bind(user.sayHi, user), 1000 );
    setTimeout(user.sayHi.bind(user), 1000); // аналог через встроенный метод

Получили простой и надёжный способ привязать контекст, причём даже встроенный в JavaScript.
Далее мы будем использовать именно встроенный метод bind.

    bind не похож на call/apply
Методы bind и call/apply близки по синтаксису, но есть важнейшее отличие.
Методы call/apply вызывают функцию с заданным контекстом и аргументами.
А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.

    Привязать всё: bindAll
Если у объекта много методов и мы планируем их активно передавать, то можно привязать контекст для них всех в цикле:

    for (var prop in user) {
    if (typeof user[prop] == 'function') {
        user[prop] = user[prop].bind(user);
    }
    }

В некоторых JS-фреймворках есть даже встроенные функции для этого, например _.bindAll(obj).


    Карринг
До этого мы говорили о привязке контекста. Теперь пойдём на шаг дальше. Привязывать можно не только контекст, но и аргументы. Используется это реже, но бывает полезно.
Карринг (currying) или каррирование – термин функционального программирования, который означает создание новой функции путём фиксирования аргументов существующей.
Как было сказано выше, метод func.bind(context, ...) может создавать обёртку, которая фиксирует не только контекст, но и ряд аргументов функции.
Например, есть функция умножения двух чисел mul(a, b):

    function mul(a, b) {
    return a * b;
    };

При помощи bind создадим функцию double, удваивающую значения. Это будет вариант функции mul с фиксированным первым аргументом:
 
    // double умножает только на два
    var double = mul.bind(null, 2); // контекст фиксируем null, он не используется

    alert( double(3) ); // = mul(2, 3) = 6
    alert( double(4) ); // = mul(2, 4) = 8
    alert( double(5) ); // = mul(2, 5) = 10


При вызове double будет передавать свои аргументы исходной функции mul после тех, которые указаны в bind, то есть в данном случае после зафиксированного первого аргумента 2.
Говорят, что double является «частичной функцией» (partial function) от mul.
Другая частичная функция triple утраивает значения:

    var triple = mul.bind(null, 3); // контекст фиксируем null, он не используется

    alert( triple(3) ); // = mul(3, 3) = 9
    alert( triple(4) ); // = mul(3, 4) = 12
    alert( triple(5) ); // = mul(3, 5) = 15

При помощи bind мы можем получить из функции её «частный вариант» как самостоятельную функцию и дальше передать в setTimeout или сделать с ней что-то ещё.
Наш выигрыш состоит в том, что эта самостоятельная функция, во-первых, имеет понятное имя (double, triple), а во-вторых, повторные вызовы позволяют не указывать каждый раз первый аргумент, он уже фиксирован благодаря bind.

    
    Функция ask для задач
В задачах этого раздела предполагается, что объявлена следующая «функция вопросов» ask:

    function ask(question, answer, ok, fail) {
    var result = prompt(question, '');
    if (result.toLowerCase() == answer.toLowerCase()) ok();
    else fail();
    }

Её назначение – задать вопрос question и, если ответ совпадёт с answer, то запустить функцию ok(), а иначе – функцию fail().
Несмотря на внешнюю простоту, функции такого вида активно используются в реальных проектах. Конечно, они будут сложнее, вместо alert/prompt – вывод красивого JavaScript-диалога с рамочками, кнопочками и так далее, но это нам сейчас не нужно.
Пример использования:

    ask("Выпустить птичку?", "да", fly, die);

    function fly() {
    alert( 'улетела :)' );
    }

    function die() {
    alert( 'птичку жалко :(' );
    }


    Итого
Функция сама по себе не запоминает контекст выполнения.
Чтобы гарантировать правильный контекст для вызова obj.func(), нужно использовать функцию-обёртку, задать её через анонимную функцию:

    setTimeout(function() {
    obj.func();
    })
    
…Либо использовать bind:

    setTimeout(obj.func.bind(obj));

Вызов bind часто используют для привязки функции к контексту, чтобы затем присвоить её в обычную переменную и вызывать уже без явного указания объекта.
Вызов bind также позволяет фиксировать первые аргументы функции («каррировать» её), и таким образом из общей функции получить её «частные» варианты – чтобы использовать их многократно без повтора одних и тех же аргументов каждый раз.









    Функции-обёртки, декораторы
JavaScript предоставляет удивительно гибкие возможности по работе с функциями: их можно передавать, в них можно записывать данные как в объекты, у них есть свои встроенные методы…
Конечно, этим нужно уметь пользоваться. В этой главе, чтобы более глубоко понимать работу с функциями, мы рассмотрим создание функций-обёрток или, иначе говоря, «декораторов».
Декоратор – приём программирования, который позволяет взять существующую функцию и изменить/расширить ее поведение.
Декоратор получает функцию и возвращает обертку, которая делает что-то своё «вокруг» вызова основной функции.

    bind – привязка контекста
Один простой декоратор вы уже видели ранее – это функция bind:

    function bind(func, context) {
    return function() {
        return func.apply(context, arguments);
    };
    }

Вызов bind(func, context) возвращает обёртку, которая ставит this и передаёт основную работу функции func.


    Декоратор-таймер
Создадим более сложный декоратор, замеряющий время выполнения функции.
Он будет называться timingDecorator и получать функцию вместе с «названием таймера», а возвращать – функцию-обёртку, которая измеряет время и прибавляет его в специальный объект timer по свойству-названию.
Использование:

    function f(x) {} // любая функция
    var timers = {}; // объект для таймеров
    // отдекорировали
    f = timingDecorator(f, "myFunc");
    // запускаем
    f(1);
    f(2);
    f(3); // функция работает как раньше, но время подсчитывается

    alert( timers.myFunc ); // общее время выполнения всех вызовов f

При помощи декоратора timingDecorator мы сможем взять произвольную функцию и одним движением руки прикрутить к ней измеритель времени.
Его реализация:

    var timers = {};
    // прибавит время выполнения f к таймеру timers[timer]
    function timingDecorator(f, timer) {
    return function() {
        var start = performance.now();

        var result = f.apply(this, arguments); // (*)

        if (!timers[timer]) timers[timer] = 0;
        timers[timer] += performance.now() - start;

        return result;
    }
    }

    // функция может быть произвольной, например такой:
    var fibonacci = function f(n) {
    return (n > 2) ? f(n - 1) + f(n - 2) : 1;
    }

    // использование: завернём fibonacci в декоратор
    fibonacci = timingDecorator(fibonacci, "fibo");

    // неоднократные вызовы...
    alert( fibonacci(10) ); // 55
    alert( fibonacci(20) ); // 6765
    // ...

    // в любой момент можно получить общее количество времени на вызовы
    alert( timers.fibo + 'мс' );


Обратим внимание на строку (*) внутри декоратора, которая и осуществляет передачу вызова:
    var result = f.apply(this, arguments); // (*)

Этот приём называется «форвардинг вызова» (от англ. forwarding): текущий контекст и аргументы через apply передаются в функцию f, так что изнутри f всё выглядит так, как была вызвана она напрямую, а не декоратор.

    Декоратор для проверки типа
В JavaScript, как правило, пренебрегают проверками типа. В функцию, которая должна получать число, может быть передана строка, булево значение или даже объект.
Например:

    function sum(a, b) {
    return a + b;
    }

    // передадим в функцию для сложения чисел нечисловые значения
    alert( sum(true, { name: "Вася", age: 35 }) ); // true[Object object]

Функция «как-то» отработала, но в реальной жизни передача в sum подобных значений, скорее всего, будет следствием программной ошибки. Всё-таки sum предназначена для суммирования чисел, а не объектов.
Многие языки программирования позволяют прямо в объявлении функции указать, какие типы данных имеют параметры. И это удобно, поскольку повышает надёжность кода.
В JavaScript же проверку типов приходится делать дополнительным кодом в начале функции, который во-первых обычно лень писать, а во-вторых он увеличивает общий объем текста, тем самым ухудшая читаемость.
Декораторы способны упростить рутинные, повторяющиеся задачи, вынести их из кода функции.
Например, создадим декоратор, который принимает функцию и массив, который описывает для какого аргумента какую проверку типа применять:

    // вспомогательная функция для проверки на число
    function checkNumber(value) {
    return typeof value == 'number';
    }

    // декоратор, проверяющий типы для f
    // второй аргумент checks - массив с функциями для проверки
    function typeCheck(f, checks) {
    return function() {
        for (var i = 0; i < arguments.length; i++) {
        if (!checks[i](arguments[i])) {
            alert( "Некорректный тип аргумента номер " + i );
            return;
        }
        }
        return f.apply(this, arguments);
    }
    }

    function sum(a, b) {
    return a + b;
    }

    // обернём декоратор для проверки
    sum = typeCheck(sum, [checkNumber, checkNumber]); // оба аргумента - числа

    // пользуемся функцией как обычно
    alert( sum(1, 2) ); // 3, все хорошо

    // а вот так - будет ошибка
    sum(true, null); // некорректный аргумент номер 0
    sum(1, ["array", "in", "sum?!?"]); // некорректный аргумент номер 1


Конечно, этот декоратор можно ещё расширять, улучшать, дописывать проверки, но… Вы уже поняли принцип, не правда ли?
Один раз пишем декоратор и дальше просто применяем этот функционал везде, где нужно.

    Декоратор проверки доступа
И наконец посмотрим ещё один, последний пример.
Предположим, у нас есть функция isAdmin(), которая возвращает true, если у посетителя есть права администратора.
Можно создать декоратор checkPermissionDecorator, который добавляет в любую функцию проверку прав:
Например, создадим декоратор checkPermissionDecorator(f). Он будет возвращать обертку, которая передает вызов f в том случае, если у посетителя достаточно прав:

    function checkPermissionDecorator(f) {
    return function() {
        if (isAdmin()) {
        return f.apply(this, arguments);
        }
        alert( 'Недостаточно прав' );
    }
    }
    Использование декоратора:

    function save() { ... }

    save = checkPermissionDecorator(save);
    // Теперь вызов функции save() проверяет права

    Итого
Декоратор – это обёртка над функцией, которая модифицирует её поведение. При этом основную работу по-прежнему выполняет функция.
Декораторы можно не только повторно использовать, но и комбинировать!
Это кардинально повышает их выразительную силу. Декораторы можно рассматривать как своего рода «фичи» или возможности, которые можно «нацепить» на любую функцию. Можно один, а можно несколько.
Скажем, используя декораторы, описанные выше, можно добавить к функции возможности по проверке типов данных, замеру времени и проверке доступа буквально одной строкой, не залезая при этом в её код, то есть (!) не увеличивая его сложность.
Предлагаю вашему вниманию задачи, которые помогут выяснить, насколько вы разобрались в декораторах. Далее в учебнике мы ещё встретимся с ними.