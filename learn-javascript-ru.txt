Типы данных:
В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».


Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено».
Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.

	var x = 123;
	x = undefined;

alert( x ); // "undefined"
В явном виде undefined обычно не присваивают, так как это противоречит его смыслу. Для записи в переменную «пустого» или «неизвестного» значения используется null.


Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений).
Например, бесконечность Infinity получается при делении на ноль:
 alert( 1 / 0 ); // Infinity
Ошибка вычислений NaN будет результатом некорректной математической операции, например:
 alert( "нечисло" * 2 ); // NaN, ошибка


Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!
Причем не важно, справа или слева находится операнд-строка, в любом случае нестроковый аргумент будет преобразован. Например:
	 alert( '1' + 2 ); // "12"
	alert( 2 + '1' ); // "21"
Это приведение к строке – особенность исключительно бинарного оператора "+".
Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.
Например:
	 alert( 2 - '1' ); // 1
	alert( 6 / '2' ); // 3


Унарный, то есть применённый к одному значению, плюс ничего не делает с числами:
	 alert( +1 ); // 1
	alert( +(1 - 2) ); // -1
Как видно, плюс ничего не изменил в выражениях. Результат – такой же, как и без него.
Тем не менее, он широко применяется, так как его «побочный эффект» – преобразование значения в число.
Например, когда мы получаем значения из HTML-полей или от пользователя, то они обычно в форме строк.
А что, если их нужно, к примеру, сложить? Бинарный плюс сложит их как строки:
	 var apples = "2";
	var oranges = "3";
	alert( apples +	 oranges ); // "23", так как бинарный плюс складывает строки
Поэтому используем унарный плюс, чтобы преобразовать к числу:
	 var apples = "2";
	var oranges = "3";
	alert( +apples + +oranges ); // 5, число, оба операнда предварительно преобразованы в числа



Аналогом «алфавита» во внутреннем представлении строк служит кодировка, у каждого символа – свой номер (код). JavaScript использует кодировку Unicode.
При этом сравниваются численные коды символов. В частности, код у символа Б больше, чем у А, поэтому и результат сравнения такой.
В кодировке Unicode обычно код у строчной буквы больше, чем у прописной.
Поэтому регистр имеет значение:
 	alert( 'а' > 'Я' ); // true, строчные буквы больше прописных
Если строка состоит из нескольких букв, то сравнение осуществляется как в телефонной книжке или в словаре. Сначала сравниваются первые буквы, потом вторые, и так далее, пока одна не будет больше другой.
Иными словами, больше – та строка, которая в телефонной книге была бы на большей странице.


	alert( "2" > "14" ); // true, неверно, ведь 2 не больше 14
В примере выше 2 оказалось больше 14, потому что строки сравниваются посимвольно, а первый символ '2' больше '1'.
Правильно было бы преобразовать их к числу явным образом. Например, поставив перед ними +:
	 alert( +"2" > +"14" ); // false, теперь правильно



При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям.
Например:
	 alert( '2' > 1 ); // true, сравнивается как 2 > 1
	alert( '01' == 1 ); // true, сравнивается как 1 == 1
	alert( false == 0 ); // true, false становится числом 0
	alert( true == 1 ); // true, так как true становится числом 1.



	alert( 0 == false ); // true
Та же ситуация с пустой строкой:
 	alert( '' == false ); // true
Это естественное следствие того, что операнды разных типов преобразовались к числу. Пустая строка, как и false, при преобразовании к числу дают 0.




Проблемы со специальными значениями возможны, когда к переменной применяется операция сравнения > < <= >=, а у неё может быть как численное значение, так и null/undefined.
Интуитивно кажется, что null/undefined эквивалентны нулю, но это не так.
Они ведут себя по-другому.
Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.
При преобразовании в число null становится 0, а undefined становится NaN.
Посмотрим забавные следствия.
Некорректный результат сравнения null с 0
Сравним null с нулём:
	 alert( null > 0 ); // false
	alert( null == 0 ); // false
Итак, мы получили, что null не больше и не равен нулю. А теперь…
     alert(null >= 0); // true
Как такое возможно? Если нечто «больше или равно нулю», то резонно полагать, что оно либо больше, либо равно. Но здесь это не так.
Дело в том, что алгоритмы проверки равенства == и сравнения >= > < <= работают по-разному.
Сравнение честно приводит к числу, получается ноль. А при проверке равенства значения null и undefined обрабатываются особым образом: они равны друг другу, но не равны чему-то ещё.
В результате получается странная с точки зрения здравого смысла ситуация, которую мы видели в примере выше.
Несравнимый undefined
Значение undefined вообще нельзя сравнивать:
	 alert( undefined > 0 ); // false (1)
	alert( undefined < 0 ); // false (2)
	alert( undefined == 0 ); // false (3)
Сравнения (1) и (2) дают false потому, что undefined при преобразовании к числу даёт NaN. А значение NaN по стандарту устроено так, что сравнения ==, <, >, <=, >= и даже === с ним возвращают false.
Проверка равенства (3) даёт false, потому что в стандарте явно прописано, что undefined равно лишь null или себе и ничему другому.
Вывод: любые сравнения с undefined/null, кроме точного ===, следует делать с осторожностью.
Желательно не использовать сравнения >= > < <= с ними, во избежание ошибок в коде.



Побитовое И (AND)	a & b	Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1.
Побитовое ИЛИ (OR)	a | b	Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1.
Побитовое исключающее ИЛИ (XOR)	a ^ b	Ставит 1 на бит результата, для которого только один из соответствующих битов операндов 			равен 1 (но не оба).
Побитовое НЕ (NOT)	~a	Заменяет каждый бит операнда на противоположный.
Левый сдвиг	`a << b`	Сдвигает двоичное представление a на b битов влево, добавляя справа нули.
Правый сдвиг, переносящий знак	`a >> b`	Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты.
Правый сдвиг с заполнением нулями	`a >>> b`	Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты 			и добавляя нули слева.




parseInt("11000", 2) – переводит строку с двоичной записью числа в число.
n.toString(2) – получает для числа n запись в 2-ной системе в виде строки.



В JavaScript побитовые операторы ^, &, | выполняются после сравнений ==.
Например, в сравнении a == b^0 будет сначала выполнено сравнение a == b, а потом уже операция ^0, как будто стоят скобки (a == b)^0.
Обычно это не то, чего мы хотим. Чтобы гарантировать желаемый порядок, нужно ставить скобки: a == (b^0).


Так как битовые операции отбрасывают десятичную часть, то их можно использовать для округления. Достаточно взять любую операцию, которая не меняет значение числа.
Например, двойное НЕ (~):
 	alert( ~~12.345 ); // 12
Подойдёт и Исключающее ИЛИ (^) с нулём:
	 alert( 12.345 ^ 0 ); // 12
Последнее даже более удобно, поскольку отлично читается:
	 alert(12.3 * 14.5 ^ 0); // (=178) "12.3 умножить на 14.5 и округлить"
У побитовых операторов достаточно низкий приоритет, он меньше чем у остальной арифметики:
	 alert( 1.1 + 1.2 ^ 0 ); // 2, сложение выполнится раньше округления


Обращение битов – это побитовое НЕ (~). То есть, при таком формате представления числа -n = ~n + 1.
Или, если перенести единицу: ~n = -(n+1).
Как видно из последнего равенства, ~n == 0 только если n == -1. Поэтому можно легко проверить равенство n == -1:
 var n = 5;
if (~n) { // сработает, т.к. ~n = -(5+1) = -6
  alert( "n не -1" ); // выведет!
}


 var n = -1;
if (~n) { // не сработает, т.к. ~n = -(-1+1) = 0
  alert( "...ничего не выведет..." );
}

Проверка на -1 пригождается, например, при поиске символа в строке. Вызов str.indexOf("подстрока") возвращает позицию подстроки в str, или -1 если не нашёл.
 var str = "Проверка";
if (~str.indexOf("верка")) { // Сочетание "if (~...indexOf)" читается как "если найдено"
  alert( 'найдено!' );
}



Оператор a << b, сдвигая биты, по сути умножает a на 2 в степени b.
Например:
	 alert( 1 << 2 ); // 1*(2*2) = 4
	alert( 1 << 3 ); // 1*(2*2*2) = 8
	alert( 3 << 3 ); // 3*(2*2*2) = 24
При этом следует иметь в виду, что максимальный верхний порог такого умножения меньше, чем обычно, так как побитовый оператор манипулирует 32-битными целыми, в то время как обычные операторы работают с числами длиной 64 бита.
Оператор сдвига в другую сторону a >> b, производит обратную операцию – целочисленное деление a на 2b.
	 alert( 8 >> 2 ); // 2 = 8/4, убрали 2 нуля в двоичном представлении
	alert( 11 >> 2 ); // 2, целочисленное деление (менее значимые биты просто отброшены)




JavaScript вычисляет несколько ИЛИ слева направо. При этом, чтобы экономить ресурсы, используется так называемый «короткий цикл вычисления».
Допустим, вычисляются несколько ИЛИ подряд: a || b || c || .... Если первый аргумент – true, то результат заведомо будет true (хотя бы одно из значений – true), и остальные значения игнорируются.
Это особенно заметно, когда выражение, переданное в качестве второго аргумента, имеет сторонний эффект – например, присваивает переменную.


Если все значения «ложные», то || возвратит последнее из них:
 	alert( undefined || '' || false || 0 ); // 0
Итак, оператор || вычисляет операнды слева направо до первого «истинного» и возвращает его, а если все ложные – то последнее значение.
Иначе можно сказать, что "|| запинается на правде".


К И применим тот же принцип «короткого цикла вычислений», но немного по-другому, чем к ИЛИ.
Если левый аргумент – false, оператор И возвращает его и заканчивает вычисления. Иначе – вычисляет и возвращает правый аргумент.


// Первый аргумент - true,
// Поэтому возвращается второй аргумент
	alert( 1 && 0 ); // 0
	alert( 1 && 5 ); // 5
// Первый аргумент - false,
// Он и возвращается, а второй аргумент игнорируется
	alert( null && 5 ); // null
	alert( 0 && "не важно" ); // 0
Можно передать и несколько значений подряд, при этом возвратится первое «ложное» (на котором остановились вычисления), а если его нет – то последнее:
	 alert( 1 && 2 && null && 3 ); // null
	alert( 1 && 2 && 3 ); // 3
Итак, оператор && вычисляет операнды слева направо до первого «ложного» и возвращает его, а если все истинные – то последнее значение.
Иначе можно сказать, что "&& запинается на лжи".


Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.
Поэтому в следующем коде сначала будет вычислено правое И: 1 && 0 = 0, а уже потом – ИЛИ.
 	alert( 5 || 1 && 0 ); // 5





Строковое преобразование происходит, когда требуется представление чего-либо в виде строки. Например, его производит функция alert.
	 var a = true;
	alert( a ); // "true"
Можно также осуществить преобразование явным вызовом String(val):
 	alert( String(null) === "null" ); // true
Как видно из примеров выше, преобразование происходит наиболее очевидным способом, «как есть»: false становится "false", null – "null", undefined – "undefined" и т.п.
Также для явного преобразования применяется оператор "+", у которого один из аргументов строка. В этом случае он приводит к строке и другой аргумент, например:
	 alert( true + "test" ); // "truetest"
	alert( "123" + undefined ); // "123undefined"



Численное преобразование происходит в математических функциях и выражениях, а также при сравнении данных различных типов (кроме сравнений ===, !==).
Для преобразования к числу в явном виде можно вызвать Number(val), либо, что короче, поставить перед выражением унарный плюс "+":
var a = +"123"; // 123
var a = Number("123"); // 123, тот же эффект
Значение	Преобразуется в...
undefined	NaN
null	0
true / false	1 / 0
Строка	Пробельные символы по краям обрезаются.Далее, если остаётся пустая строка, то 0, иначе из непустой строки "считывается" число, при ошибке результат NaN.



// после обрезания пробельных символов останется "123"
alert( +"   \n  123   \n  \n" ); // 123
Ещё примеры:
	Логические значения:
		 alert( +true ); // 1
		alert( +false ); // 0
	Сравнение разных типов – значит численное преобразование:
	 alert( "\n0 " == 0 ); // true
	При этом строка "\n0" преобразуется к числу, как указано выше: начальные и конечные пробелы обрезаются, получается строка "0", которая равна 0.
	С логическими значениями:
		 alert( "\n" == false );
		alert( "1" == true );
Здесь сравнение "==" снова приводит обе части к числу. В первой строке слева и справа получается 0, во второй 1.




Специальные значения
Посмотрим на поведение специальных значений более внимательно.
Интуитивно, значения null/undefined ассоциируются с нулём, но при преобразованиях ведут себя иначе.
Специальные значения преобразуются к числу так
undefined			NaN
null				0
Это преобразование осуществляется при арифметических операциях и сравнениях > >= < <=, но не при проверке равенства ==. Алгоритм проверки равенства для этих значений в спецификации прописан отдельно (пункт 11.9.3). В нём считается, что null и undefined равны "==" между собой, но эти значения не равны никакому другому значению.
Это ведёт к забавным последствиям.
Например, null не подчиняется законам математики – он «больше либо равен нулю»: null>=0, но не больше и не равен:
	 alert( null >= 0 ); // true, т.к. null преобразуется к 0
	alert( null > 0 ); // false (не больше), т.к. null преобразуется к 0
	alert( null == 0 ); // false (и не равен!), т.к. == рассматривает null особо.
Значение undefined вообще «несравнимо»:
	 alert( undefined > 0 ); // false, т.к. undefined -> NaN
	alert( undefined == 0 ); // false, т.к. это undefined (без преобразования)
	alert( undefined < 0 ); // false, т.к. undefined -> NaN
Для более очевидной работы кода и во избежание ошибок лучше не давать специальным значениям участвовать в сравнениях > >= < <=.
Используйте в таких случаях переменные-числа или приводите к числу явно.



Преобразование к true/false происходит в логическом контексте, таком как if(value), и при применении логических операторов.
Все значения, которые интуитивно «пусты», становятся false. Их несколько: 0, пустая строка, null, undefined и NaN.
Остальное, в том числе и любые объекты – true.
Полная таблица преобразований:
	undefined, null		false
	Числа				Все true, кроме 0, NaN -- false.
	Строки				Все true, кроме пустой строки "" -- false
	Объекты			Всегда true



Для явного преобразования используется двойное логическое отрицание !!value или вызов Boolean(value).
Обратите внимание: строка "0" становится true
В отличие от многих языков программирования (например PHP), "0" в JavaScript является true, как и строка из пробелов:
	 alert( !!"0" ); // true
	alert( !!" " ); // любые непустые строки, даже из пробелов - true!
Логическое преобразование интересно тем, как оно сочетается с численным.
Два значения могут быть равны, но одно из них в логическом контексте true, другое – false.
Например, равенство в следующем примере верно, так как происходит численное преобразование:
 	alert( 0 == "\n0\n" ); // true
… А в логическом контексте левая часть (0) даст false, правая ("\n0\n") – true, так как любая не пустая строка в логическом контексте равна true:
	 if ("\n0\n") {
	  alert( "true, совсем не как 0!" );
	}
С точки зрения преобразования типов в JavaScript это совершенно нормально. При сравнении с помощью «==» – численное преобразование, а в if – логическое, только и всего.


	{
					Вычислить сумму чисел до данного
				важность: 5
				Напишите функцию sumTo(n), которая для данного n вычисляет сумму чисел от 1 до n, например:

				sumTo(1) = 1
				sumTo(2) = 2 + 1 = 3
				sumTo(3) = 3 + 2 + 1 = 6
				sumTo(4) = 4 + 3 + 2 + 1 = 10
				...
				sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050
				Сделайте три варианта решения:

				С использованием цикла.
				Через рекурсию, т.к. sumTo(n) = n + sumTo(n-1) для n > 1.
				С использованием формулы для суммы арифметической прогрессии.
				Пример работы вашей функции:

				function sumTo(n) { /*... ваш код ... */ }

				alert( sumTo(100) ); // 5050
				Какой вариант решения самый быстрый? Самый медленный? Почему?

				Можно ли при помощи рекурсии посчитать sumTo(100000)? Если нет, то почему?

				решение
				Решение с использованием цикла:

				 function sumTo(n) {
				  var sum = 0;
				  for (var i = 1; i <= n; i++) {
				    sum += i;
				  }
				  return sum;
				}

				alert( sumTo(100) );
				Решение через рекурсию:

				 function sumTo(n) {
				  if (n == 1) return 1;
				  return n + sumTo(n - 1);
				}

				alert( sumTo(100) );
				Решение по формуле: sumTo(n) = n*(n+1)/2:

				 function sumTo(n) {
				  return n * (n + 1) / 2;
				}

				alert( sumTo(100) );
				P.S. Надо ли говорить, что решение по формуле работает быстрее всех? Это очевидно. Оно использует всего три операции для любого n, а цикл и рекурсия требуют как минимум n операций сложения.

				Вариант с циклом – второй по скорости. Он быстрее рекурсии, так как операций сложения столько же, но нет дополнительных вычислительных затрат на организацию вложенных вызовов.

				Рекурсия в данном случае работает медленнее всех.

				P.P.S. Существует ограничение глубины вложенных вызовов, поэтому рекурсивный вызов sumTo(100000) выдаст ошибку.


				Вычислить факториал
				важность: 4
				Факториа́л числа – это число, умноженное на «себя минус один», затем на «себя минус два» и так далее, до единицы. Обозначается n!

				Определение факториала можно записать как:

				n! = n * (n - 1) * (n - 2) * ...*1
				Примеры значений для разных n:

				1! = 1
				2! = 2 * 1 = 2
				3! = 3 * 2 * 1 = 6
				4! = 4 * 3 * 2 * 1 = 24
				5! = 5 * 4 * 3 * 2 * 1 = 120
				Задача – написать функцию factorial(n), которая возвращает факториал числа n!, используя рекурсивный вызов.

				alert( factorial(5) ); // 120
				Подсказка: обратите внимание, что n! можно записать как n * (n-1)!. Например: 3! = 3*2! = 3*2*1! = 6

				решение
				По свойствам факториала, как описано в условии, n! можно записать как n * (n-1)!.

				То есть, результат функции для n можно получить как n, умноженное на результат функции для n-1, и так далее до 1!:

				 function factorial(n) {
				  return (n != 1) ? n * factorial(n - 1) : 1;
				}

				alert( factorial(5) ); // 120
				Базисом рекурсии является значение 1. А можно было бы сделать базисом и 0. Тогда код станет чуть короче:

				 function factorial(n) {
				  return n ? n * factorial(n - 1) : 1;
				}

				alert( factorial(5) ); // 120
				В этом случае вызов factorial(1) сведётся к 1*factorial(0), будет дополнительный шаг рекурсии.


				Числа Фибоначчи
				важность: 5
				Последовательность чисел Фибоначчи имеет формулу Fn = Fn-1 + Fn-2. То есть, следующее число получается как сумма двух предыдущих.

				Первые два числа равны 1, затем 2(1+1), затем 3(1+2), 5(2+3) и так далее: 1, 1, 2, 3, 5, 8, 13, 21....

				Числа Фибоначчи тесно связаны с золотым сечением и множеством природных явлений вокруг нас.

				Напишите функцию fib(n), которая возвращает n-е число Фибоначчи. Пример работы:

				function fib(n) { /* ваш код */ }

				alert( fib(3) ); // 2
				alert( fib(7) ); // 13
				alert( fib(77)); // 5527939700884757
				Все запуски функций из примера выше должны срабатывать быстро.

				решение
				Вычисление рекурсией (медленное)
				Решение по формуле, используя рекурсию:

				 function fib(n) {
				  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
				}

				alert( fib(3) ); // 2
				alert( fib(7) ); // 13
				// fib(77); // не запускаем, подвесит браузер
				При больших значениях n оно будет работать очень медленно. Например, fib(77) уже будет вычисляться очень долго.

				Это потому, что функция порождает обширное дерево вложенных вызовов. При этом ряд значений вычисляется много раз. Например, посмотрим на отрывок вычислений:

				...
				fib(5) = fib(4) + fib(3)
				fib(4) = fib(3) + fib(2)
				...
				Здесь видно, что значение fib(3) нужно одновременно и для fib(5) и для fib(4). В коде оно будет вычислено два раза, совершенно независимо.

				Можно это оптимизировать, запоминая уже вычисленные значения, получится гораздо быстрее. Альтернативный вариант – вообще отказаться от рекурсии, а вместо этого в цикле начать с первых значений 1, 2, затем из них получить fib(3), далее fib(4), затем fib(5) и так далее, до нужного значения.

				Это решение будет наиболее эффективным. Попробуйте его написать.

				Алгоритм вычисления в цикле
				Будем идти по формуле слева-направо:

				var a = 1, b = 1; // начальные значения
				var c = a + b; // 2

				/* переменные на начальном шаге:
				a  b  c
				1, 1, 2
				*/
				Теперь следующий шаг, присвоим a и b текущие 2 числа и получим новое следующее в c:

				a = b, b = c;
				c = a + b;

				/* стало так (ещё число):
				   a  b  c
				1, 1, 2, 3
				*/
				Следующий шаг даст нам ещё одно число последовательности:

				a = b, b = c;
				c = a + b;

				/* стало так (ещё число):
				      a  b  c
				1, 1, 2, 3, 5
				*/
				Повторять в цикле до тех пор, пока не получим нужное значение. Это гораздо быстрее, чем рекурсия, хотя бы потому что ни одно из чисел не вычисляется дважды.

				P.S. Этот подход к вычислению называется динамическое программирование снизу-вверх.

				Код для вычисления в цикле
				 function fib(n) {
				  var a = 1,
				    b = 1;
				  for (var i = 3; i <= n; i++) {
				    var c = a + b;
				    a = b;
				    b = c;
				  }
				  return b;
				}

				alert( fib(3) ); // 2
				alert( fib(7) ); // 13
				alert( fib(77) ); // 5527939700884757
				Цикл здесь начинается с i=3, так как первое и второе числа Фибоначчи заранее записаны в переменные a=1, b=1.
					}




Function Declaration и Expression
Функция в JavaScript является обычным значением.

Её можно создать в любом месте кода и присвоить в переменную, вот так:

 var sum = function(a, b) {
  var result = a + b;

  return result;
}

alert( sum(1, 2) ); // 3
Такой синтаксис, при котором функция объявляется в контексте выражения (в данном случае, выражения присваивания), называется Function Expression, а обычный синтаксис, при котором функция объявляется в основном потоке кода – Function Declaration.

Функции, объявленные через Function Declaration, отличаются от Function Expression тем, что интерпретатор создаёт их при входе в область видимости (в начале выполнения скрипта), так что они работают до объявления.

Обычно это удобно, но может быть проблемой, если нужно объявить функцию в зависимости от условия. В этом случае, а также в других ситуациях, когда хочется создать функцию «здесь и сейчас», используют Function Expression.

Детали: Функциональные выражения.

Named Function Expression
Если объявление функции является частью какого-либо выражения, например var f = function... или любого другого, то это Function Expression.

В этом случае функции можно присвоить «внутреннее» имя, указав его после function. Оно будет видно только внутри этой функции и позволяет обратиться к функции изнутри себя. Обычно это используется для рекурсивных вызовов.

Например, создадим функцию для вычисления факториала как Function Expression и дадим ей имя me:
var factorial = function me(n) {
  return (n == 1) ? n : n * me(n - 1);
}

alert( factorial(5) ); // 120
alert( me ); // ошибка, нет такой переменной
Ограничение видимости для имени не работает в IE8-, но вызов с его помощью работает во всех браузерах.