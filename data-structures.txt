Все значения в JavaScript, за исключением null и undefined, содержат набор вспомогательных функций и значений, доступных «через точку».
Такие функции называют «методами», а значения – «свойствами». Здесь мы рассмотрим основы использования свойств и методов.

Числа
Все числа в JavaScript, как целые так и дробные, имеют тип Number и хранятся в 64-битном формате IEEE-754, также известном как «double precision».

	Способы записи
В JavaScript можно записывать числа не только в десятичной, но и в шестнадцатеричной (начинается с 0x) системе счисления:
 	alert( 0xFF ); // 255 в шестнадцатиричной системе
Также доступна запись в «научном формате» (ещё говорят «запись с плавающей точкой»), который выглядит как <число>e<количество нулей>.
Например, 1e3 – это 1 с 3 нулями, то есть 1000.
	 // еще пример научной формы: 3 с 5 нулями
	alert( 3e5 ); // 300000
Если количество нулей отрицательно, то число сдвигается вправо за десятичную точку, так что получается десятичная дробь:
	 // здесь 3 сдвинуто 5 раз вправо, за десятичную точку.
	alert( 3e-5 ); // 0.00003  <-- 5 нулей, включая начальный ноль

	Деление на ноль, Infinity
Представьте, что вы собираетесь создать новый язык… Люди будут называть его «JavaScript» (или «LiveScript»… неважно).
Что должно происходить при попытке деления на ноль?
Как правило, ошибка в программе… Во всяком случае, в большинстве языков программирования это именно так.
Но создатель JavaScript решил пойти математически правильным путем. Ведь чем меньше делитель, тем больше результат. При делении на очень-очень маленькое число должно получиться очень большое. В математическом анализе это описывается через пределы, и если подразумевать предел, то в качестве результата деления на 0 мы получаем «бесконечность», которая обозначается символом ∞ (в JavaScript Infinity).
	 alert( 1 / 0 ); // Infinity
	alert( 12345 / 0 ); // Infinity
Infinity – особенное численное значение, которое ведет себя в точности как математическая бесконечность ∞.
Infinity больше любого числа.
Добавление к бесконечности не меняет её.
	 alert( Infinity > 1234567890 ); // true
	alert( Infinity + 5 == Infinity ); // true
Бесконечность можно присвоить и в явном виде: var x = Infinity.
Бывает и минус бесконечность -Infinity:
 	alert( -1 / 0 ); // -Infinity
Бесконечность можно получить также, если сделать ну очень большое число, для которого количество разрядов в двоичном представлении не помещается в соответствующую часть стандартного 64-битного формата, например:
	 alert( 1e500 ); // Infinity

	NaN
Если математическая операция не может быть совершена, то возвращается специальное значение NaN (Not-A-Number).
Например, деление 0/0 в математическом смысле неопределено, поэтому его результат NaN:
 	alert( 0 / 0 ); // NaN
Значение NaN используется для обозначения математической ошибки и обладает следующими свойствами:
	Значение NaN – единственное в своем роде, которое не равно ничему, включая себя.
Следующий код ничего не выведет:
	 if (NaN == NaN) alert( "==" ); // Ни один вызов
	if (NaN === NaN) alert( "===" ); // не сработает
Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает true, если получилось NaN, и false – для любого другого значения.
	 var n = 0 / 0;
	alert( isNaN(n) ); // true
	alert( isNaN("12") ); // false, строка преобразовалась к обычному числу 12
Значение NaN «прилипчиво». Любая операция с NaN возвращает NaN.
 	alert( NaN + 1 ); // NaN
Если аргумент isNaN – не число, то он автоматически преобразуется к числу.
Забавный способ проверки на NaN
Отсюда вытекает забавный способ проверки значения на NaN: можно проверить значение на равенство самому себе, если не равно – то NaN:
	 var n = 0 / 0;
	if (n !== n) alert( 'n = NaN!' );
Это работает, но для наглядности лучше использовать isNaN(n).
	Математические операции в JS безопасны
	Никакие математические операции в JavaScript не могут привести к ошибке или «обрушить» программу.
	В худшем случае результат будет NaN.


	isFinite(n)
Итак, в JavaScript есть обычные числа и три специальных числовых значения: NaN, Infinity и -Infinity.
Тот факт, что они, хоть и особые, но числа, демонстрируется работой оператора +:
	var value = prompt("Введите Infinity", 'Infinity');
	var number = +value;
	alert( number ); // Infinity, плюс преобразовал строку "Infinity" к такому "числу"
Обычно если мы хотим от посетителя получить число, то Infinity или NaN нам не подходят. Для того чтобы отличить «обычные» числа от таких специальных значений, существует функция isFinite.
Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity:
	 alert( isFinite(1) ); // true
	alert( isFinite(Infinity) ); // false
	alert( isFinite(NaN) ); // false


	Преобразование к числу
Большинство арифметических операций и математических функций преобразуют значение в число автоматически.
Для того чтобы сделать это явно, обычно перед значением ставят унарный плюс '+':
	 var s = "12.34";
	alert( +s ); // 12.34
При этом, если строка не является в точности числом, то результат будет NaN:
	 alert( +"12test" ); // NaN
Единственное исключение – пробельные символы в начале и в конце строки, которые игнорируются:
	 alert( +"  -12" ); // -12
	alert( +" \n34  \n" ); // 34, перевод строки \n является пробельным символом
	alert( +"" ); // 0, пустая строка становится нулем
	alert( +"1 2" ); // NaN, пробел посередине числа - ошибка
Аналогичным образом происходит преобразование и в других математических операторах и функциях:
 	alert( '12.34' / "-2" ); // -6.17


 	Мягкое преобразование: parseInt и parseFloat
В мире HTML/CSS многие значения не являются в точности числами. Например метрики CSS: 10pt или -12px.
Оператор '+' для таких значений возвратит NaN:
	 alert(+"12px") // NaN
Для удобного чтения таких значений существует функция parseInt:
 	alert( parseInt('12px') ); // 12
Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.
При возникновении ошибки возвращается число, которое получилось. Функция parseInt читает из строки целое число, а parseFloat – дробное.
	 alert( parseInt('12px') ) // 12, ошибка на символе 'p'
	alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке
Конечно, существуют ситуации, когда parseInt/parseFloat возвращают NaN. Это происходит при ошибке на первом же символе:
 	alert( parseInt('a123') ); // NaN
Функция parseInt также позволяет указать систему счисления, то есть считывать числа, заданные в шестнадцатиричной и других системах счисления:
 	alert( parseInt('FF', 16) ); // 255


 	Проверка на число
Для проверки строки на число можно использовать функцию isNaN(str).
Она преобразует строку в число аналогично +, а затем вернёт true, если это NaN, то есть если преобразование не удалось:
	 var x = prompt("Введите значение", "-11.5");
	if (isNaN(x)) {
	  alert( "Строка преобразовалась в NaN. Не число" );
	} else {
	  alert( "Число" );
	}
Однако, у такой проверки есть две особенности:
Пустая строка и строка из пробельных символов преобразуются к 0, поэтому считаются числами.
Если применить такую проверку не к строке, то могут быть сюрпризы, в частности isNaN посчитает числами значения false, true, null, так как они хотя и не числа, но преобразуются к ним.
	 alert( isNaN(null) ); //  false - не NaN, т.е. "число"
	alert( isNaN("\n  \n") ); //  false - не NaN, т.е. "число"
Если такое поведение допустимо, то isNaN – приемлемый вариант.
Если же нужна действительно точная проверка на число, которая не считает числом строку из пробелов, логические и специальные значения, а также отсекает Infinity – используйте следующую функцию isNumeric:
	function isNumeric(n) {
	  return !isNaN(parseFloat(n)) && isFinite(n);
	}
Разберёмся, как она работает. Начнём справа.
Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не Infinity/-Infinity/NaN.
Таким образом, правая часть отсеет заведомо не-числа, но оставит такие значения как true/false/null и пустую строку '', так как они корректно преобразуются в числа.
Для их проверки нужна левая часть. Вызов parseFloat(true/false/null/'') вернёт NaN для этих значений.
Так устроена функция parseFloat: она преобразует аргумент к строке, то есть true/false/null становятся "true"/"false"/"null", а затем считывает из неё число, при этом пустая строка даёт NaN.
В результате отсеивается всё, кроме строк-чисел и обычных чисел.


	toString(система счисления)
Как показано выше, числа можно записывать не только в 10-ричной, но и в 16-ричной системе. Но бывает и противоположная задача: получить 16-ричное представление числа. Для этого используется метод toString(основание системы), например:
	 var n = 255;
	alert( n.toString(16) ); // ff
В частности, это используют для работы с цветовыми значениями в браузере, вида #AABBCC.
Основание может быть любым от 2 до 36.
Основание 2 бывает полезно для отладки побитовых операций:
	 var n = 4;
	alert( n.toString(2) ); // 100
Основание 36 (по количеству букв в английском алфавите – 26, вместе с цифрами, которых 10) используется для того, чтобы «кодировать» число в виде буквенно-цифровой строки. В этой системе счисления сначала используются цифры, а затем буквы от a до z:
	 var n = 1234567890;
	alert( n.toString(36) ); // kf12oi
При помощи такого кодирования можно «укоротить» длинный цифровой идентификатор, например чтобы выдать его в качестве URL.


	Округление
Одна из самых частых операций с числом – округление. В JavaScript существуют целых 3 функции для этого.
Math.floor
Округляет вниз
Math.ceil
Округляет вверх
Math.round
Округляет до ближайшего целого
		 alert( Math.floor(3.1) );  // 3
		alert( Math.ceil(3.1) );   // 4
		alert( Math.round(3.1) );  // 3
	Округление битовыми операторами
Битовые операторы делают любое число 32-битным целым, обрезая десятичную часть.
В результате побитовая операция, которая не изменяет число, например, двойное битовое НЕ – округляет его:
 	alert( ~~12.3 ); // 12
Любая побитовая операция такого рода подойдет, например XOR (исключающее ИЛИ, "^") с нулем:
	 alert( 12.3 ^ 0 ); // 12
	alert( 1.2 + 1.3 ^ 0 ); // 2, приоритет ^ меньше, чем +
Это удобно в первую очередь тем, что легко читается и не заставляет ставить дополнительные скобки как Math.floor(...):
	var x = a * b / c ^ 0; // читается как "a * b / c и округлить"



	Округление до заданной точности
Для округления до нужной цифры после запятой можно умножить и поделить на 10 с нужным количеством нулей. Например, округлим 3.456 до 2-го знака после запятой:
	 var n = 3.456;
	alert( Math.round(n * 100) / 100 ); // 3.456 -> 345.6 -> 346 -> 3.46
Таким образом можно округлять число и вверх и вниз.


	num.toFixed(precision)
Существует также специальный метод num.toFixed(precision), который округляет число num до точности precision и возвращает результат в виде строки:
	 var n = 12.34;
	alert( n.toFixed(1) ); // "12.3"
Округление идёт до ближайшего значения, аналогично Math.round:
	 var n = 12.36;
	alert( n.toFixed(1) ); // "12.4"
Итоговая строка, при необходимости, дополняется нулями до нужной точности:
	 var n = 12.34;
	alert( n.toFixed(5) ); // "12.34000", добавлены нули до 5 знаков после запятой
Если нам нужно именно число, то мы можем получить его, применив '+' к результату n.toFixed(..):
		 var n = 12.34;
		alert( +n.toFixed(5) ); // 12.34
	Метод toFixed не эквивалентен Math.round!
Например, произведём округление до одного знака после запятой с использованием двух способов: toFixed и Math.round с умножением и делением:
	 var price = 6.35;
	alert( price.toFixed(1) ); // 6.3
	alert( Math.round(price * 10) / 10 ); // 6.4
Как видно результат разный! Вариант округления через Math.round получился более корректным, так как по общепринятым правилам 5 округляется вверх. А toFixed может округлить его как вверх, так и вниз.
	Во внутреннем двоичном представлении 6.35 является бесконечной двоичной дробью. Хранится она с потерей точности… А впрочем, посмотрим сами:
	 alert( 6.35.toFixed(20) ); // 6.34999999999999964473
	Интерпретатор видит число как 6.34..., поэтому и округляет вниз.


	Неточные вычисления
Запустите этот пример:
 	alert( 0.1 + 0.2 == 0.3 );
Запустили? Если нет – все же сделайте это.
Ок, вы запустили его. Он вывел false. Результат несколько странный, не так ли? Возможно, ошибка в браузере? Поменяйте браузер, запустите еще раз.
Хорошо, теперь мы можем быть уверены: 0.1 + 0.2 это не 0.3. Но тогда что же это?
 	alert( 0.1 + 0.2 ); // 0.30000000000000004
Как видите, произошла небольшая вычислительная ошибка, результат сложения 0.1 + 0.2 немного больше, чем 0.3.
 	alert( 0.1 + 0.2 > 0.3 ); // true
Всё дело в том, что в стандарте IEEE 754 на число выделяется ровно 8 байт(=64 бита), не больше и не меньше.
Число 0.1 (одна десятая) записывается просто в десятичном формате. Но в двоичной системе счисления это бесконечная дробь, так как единица на десять в двоичной системе так просто не делится. Также бесконечной дробью является 0.2 (=2/10).
Двоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность. Её даже можно увидеть:
 	alert( 0.1.toFixed(20) ); // 0.10000000000000000555
Когда мы складываем 0.1 и 0.2, то две неточности складываются, получаем незначительную, но всё же ошибку в вычислениях.
Конечно, это не означает, что точные вычисления для таких чисел невозможны. Они возможны. И даже необходимы.
Например, есть два способа сложить 0.1 и 0.2:
Сделать их целыми, сложить, а потом поделить:
 	alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
Это работает, так как числа 0.1*10 = 1 и 0.2*10 = 2 могут быть точно представлены в двоичной системе.
Сложить, а затем округлить до разумного знака после запятой. Округления до 10-го знака обычно бывает достаточно, чтобы отсечь ошибку вычислений:
	 var result = 0.1 + 0.2;
	alert( +result.toFixed(10) ); // 0.3
		Забавный пример
Привет! Я – число, растущее само по себе!
 	alert( 9999999999999999 ); // выведет 10000000000000000
Причина та же – потеря точности.
Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит хранят позицию десятичной точки и один бит – знак. Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.
Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число», что мы и видим в примере выше. Как говорится: «как смог, так записал».
Ради справедливости заметим, что в точности то же самое происходит в любом другом языке, где используется формат IEEE 754, включая Java, C, PHP, Ruby, Perl.


Тригонометрия
Встроенные функции для тригонометрических вычислений:
Math.acos(x)
Возвращает арккосинус x (в радианах)
Math.asin(x)
Возвращает арксинус x (в радианах)
Math.atan(x)
Возвращает арктангенс x (в радианах)
Math.atan2(y, x)
Возвращает угол до точки (y, x). Описание функции: Atan2.
Math.sin(x)
Вычисляет синус x
Math.cos(x)
Вычисляет косинус x
Math.tan(x)
Возвращает тангенс x
Функции общего назначения
Разные полезные функции:
Math.sqrt(x)
Возвращает квадратный корень из x.
Math.log(x)
Возвращает натуральный (по основанию e) логарифм x.
Math.pow(x, exp)
Возводит число в степень, возвращает xexp, например Math.pow(2,3) = 8. Работает в том числе с дробными и отрицательными степенями, например: Math.pow(4, -1/2) = 0.5.
Math.abs(x)
Возвращает абсолютное значение числа
Math.exp(x)
Возвращает ex, где e – основание натуральных логарифмов.
Math.max(a, b, c...)
Возвращает наибольший из списка аргументов
Math.min(a, b, c...)
Возвращает наименьший из списка аргументов
Math.random()
Возвращает псевдослучайное число в интервале [0,1) – то есть между 0 (включительно) и 1 (не включая). Генератор случайных чисел инициализуется текущим временем.






















Строки
	Экранирование специальных символов
Если строка в одинарных кавычках, то внутренние одинарные кавычки внутри должны быть экранированы, то есть снабжены обратным слешем \', вот так:
	var str = 'I\'m a JavaScript programmer';
В двойных кавычках – экранируются внутренние двойные:
	 var str = "I'm a JavaScript \"programmer\" ";
	alert( str ); // I'm a JavaScript "programmer"
Экранирование служит исключительно для правильного восприятия строки JavaScript. В памяти строка будет содержать сам символ без '\'. Вы можете увидеть это, запустив пример выше.
Сам символ обратного слэша '\' является служебным, поэтому всегда экранируется, т.е пишется как \\:
	 var str = ' символ \\ ';
	alert( str ); // символ \
Заэкранировать можно любой символ. Если он не специальный, то ничего не произойдёт:
	 alert( "\a" ); // a
	// идентично alert(  "a"  );


	Длина length
Одно из самых частых действий со строкой – это получение ее длины:
		 var str = "My\n"; // 3 символа. Третий - перевод строки
		alert( str.length ); // 3
	Доступ к символам
Чтобы получить символ, используйте вызов charAt(позиция). Первый символ имеет позицию 0:
	 var str = "jQuery";
	alert( str.charAt(0) ); // "j"
В JavaScript нет отдельного типа «символ», так что charAt возвращает строку, состоящую из выбранного символа.
Также для доступа к символу можно использовать квадратные скобки:
	 var str = "Я - современный браузер!";
	alert( str[0] ); // "Я"
Разница между этим способом и charAt заключается в том, что если символа нет – charAt выдает пустую строку, а скобки – undefined:
	 alert( "".charAt(0) ); // пустая строка
	alert( "" [0] ); // undefined
Вообще же метод charAt существует по историческим причинам, ведь квадратные скобки – проще и короче.
	Вызов метода – всегда со скобками
Обратите внимание, str.length – это свойство строки, а str.charAt(pos) – метод, т.е. функция.
Обращение к методу всегда идет со скобками, а к свойству – без скобок.


	Изменения строк
Содержимое строки в JavaScript нельзя изменять. Нельзя взять символ посередине и заменить его. Как только строка создана – она такая навсегда.

Можно лишь создать целиком новую строку и присвоить в переменную вместо старой, например:
		 var str = "строка";
		str = str[3] + str[4] + str[5];
		alert( str ); // ока
	Смена регистра
Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний:
 	alert( "Интерфейс".toUpperCase() ); // ИНТЕРФЕЙС
Пример ниже получает первый символ и приводит его к нижнему регистру:
	alert( "Интерфейс" [0].toLowerCase() ); // 'и'



	Поиск подстроки
Для поиска подстроки есть метод indexOf(подстрока[, начальная_позиция]).
Он возвращает позицию, на которой находится подстрока или -1, если ничего не найдено. Например:
	var str = "Widget with id";
	alert( str.indexOf("Widget") ); // 0, т.к. "Widget" найден прямо в начале str
	alert( str.indexOf("id") ); // 1, т.к. "id" найден, начиная с позиции 1
	alert( str.indexOf("widget") ); // -1, не найдено, так как поиск учитывает регистр
Необязательный второй аргумент позволяет искать, начиная с указанной позиции. Например, первый раз "id" появляется на позиции 1. Чтобы найти его следующее появление – запустим поиск с позиции 2:
	var str = "Widget with id";
	alert(str.indexOf("id", 2)) // 12, поиск начат с позиции 2
Также существует аналогичный метод lastIndexOf, который ищет не с начала, а с конца строки.
	На заметку:
Для красивого вызова indexOf применяется побитовый оператор НЕ '~'.
Дело в том, что вызов ~n эквивалентен выражению -(n+1), например:
	alert( ~2 ); // -(2+1) = -3
	alert( ~1 ); // -(1+1) = -2
	alert( ~0 ); // -(0+1) = -1
	alert( ~-1 ); // -(-1+1) = 0
Как видно, ~n – ноль только в случае, когда n == -1.
То есть, проверка if ( ~str.indexOf(...) ) означает, что результат indexOf отличен от -1, т.е. совпадение есть.
Вот так:
	var str = "Widget";
	if (~str.indexOf("get")) {
	  alert( 'совпадение есть!' );
	}
Вообще, использовать возможности языка неочевидным образом не рекомендуется, поскольку ухудшает читаемость кода.
Однако, в данном случае, все в порядке. Просто запомните: '~' читается как «не минус один», а "if ~str.indexOf" читается как "если найдено".


	Поиск всех вхождений
Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Как только получаем очередную позицию – начинаем следующий поиск со следующей.
Пример такого цикла:
	 var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке
	var target = "Иа"; // цель поиска
	var pos = 0;
	while (true) {
	  var foundPos = str.indexOf(target, pos);
	  if (foundPos == -1) break;

	  alert( foundPos ); // нашли на этой позиции
	  pos = foundPos + 1; // продолжить поиск со следующей
	}
Такой цикл начинает поиск с позиции 0, затем найдя подстроку на позиции foundPos, следующий поиск продолжит с позиции pos = foundPos+1, и так далее, пока что-то находит.
Впрочем, тот же алгоритм можно записать и короче:
	var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке
	var target = "Иа"; // цель поиска
	var pos = -1;
	while ((pos = str.indexOf(target, pos + 1)) != -1) {
	  alert( pos );
	}



	Взятие подстроки: substring, substr, slice
В JavaScript существуют целых 3 (!) метода для взятия подстроки, с небольшими отличиями между ними.

substring(start [, end])
Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end.
     var str = "stringify";
	alert(str.substring(0,1)); // "s", символы с позиции 0 по 1 не включая 1.
Если аргумент end отсутствует, то идет до конца строки:
     var str = "stringify";
	alert(str.substring(2)); // ringify, символы с позиции 2 до конца
substr(start [, length])
Первый аргумент имеет такой же смысл, как и в substring, а второй содержит не конечную позицию, а количество символов.
    var str = "stringify";
	str = str.substr(2,4); // ring, со 2-й позиции 4 символа
	alert(str)
Если второго аргумента нет – подразумевается «до конца строки».
slice(start [, end])
Возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров – такой же как в substring.

	Отрицательные аргументы
Различие между substring и slice – в том, как они работают с отрицательными и выходящими за границу строки аргументами:

substring(start, end)
Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки:
 	alert( "testme".substring(-2) ); // "testme", -2 становится 0
Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end:
	 alert( "testme".substring(4, -1) ); // "test"
	// -1 становится 0 -> получили substring(4, 0)
	// 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"

slice
Отрицательные значения отсчитываются от конца строки:
	 alert( "testme".slice(-2) ); // "me", от 2 позиции с конца
	 alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.
Это гораздо более удобно, чем странная логика substring.
Отрицательное значение первого параметра поддерживается в substr во всех браузерах, кроме IE8-.
Если выбирать из этих трёх методов один, для использования в большинстве ситуаций – то это будет slice: он и отрицательные аргументы поддерживает и работает наиболее очевидно.



Кодировка Юникод
Как мы знаем, символы сравниваются в алфавитном порядке 'А' < 'Б' < 'В' < ... < 'Я'.
Но есть несколько странностей…
1 - Почему буква 'а' маленькая больше буквы 'Я' большой?
 	alert( 'а' > 'Я' ); // true
2 - Буква 'ё' находится в алфавите между е и ж: абвгдеёжз…. Но почему тогда 'ё' больше 'я'?
 	alert( 'ё' > 'я' ); // true
Чтобы разобраться с этим, обратимся к внутреннему представлению строк в JavaScript.

Все строки имеют внутреннюю кодировку Юникод.
Неважно, на каком языке написана страница, находится ли она в windows-1251 или utf-8. Внутри JavaScript-интерпретатора все строки приводятся к единому «юникодному» виду. Каждому символу соответствует свой код.
Есть метод для получения символа по его коду:
	String.fromCharCode(code)
Возвращает символ по коду code:
 	alert( String.fromCharCode(1072) ); // 'а'
…И метод для получения цифрового кода из символа:
	str.charCodeAt(pos)
Возвращает код символа на позиции pos. Отсчет позиции начинается с нуля.
 	alert( "абрикос".charCodeAt(0) ); // 1072, код 'а'
Теперь вернемся к примерам выше. Почему сравнения 'ё' > 'я' и 'а' > 'Я' дают такой странный результат?
Дело в том, что символы сравниваются не по алфавиту, а по коду. У кого код больше – тот и больше. В юникоде есть много разных символов. Кириллическим буквам соответствует только небольшая часть из них, подробнее – Кириллица в Юникоде.
Выведем отрезок символов юникода с кодами от 1034 до 1113:
	 var str = '';
	for (var i = 1034; i <= 1113; i++) {
	  str += String.fromCharCode(i);
	}
	alert( str );
Результат:
ЊЋЌЍЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюяѐёђѓєѕіїјљ
Мы можем увидеть из этого отрезка две важных вещи:
Строчные буквы идут после заглавных, поэтому они всегда больше.
В частности, 'а'(код 1072) > 'Я'(код 1071).
То же самое происходит и в английском алфавите, там 'a' > 'Z'.
Ряд букв, например ё, находятся вне основного алфавита.
В частности, маленькая буква ё имеет код, больший чем я, поэтому 'ё'(код 1105) > 'я'(код 1103).
Кстати, большая буква Ё располагается в Unicode до А, поэтому 'Ё'(код 1025) < 'А'(код 1040). Удивительно: есть буква меньше чем А :)
Буква ё не уникальна, точки над буквой используются и в других языках, приводя к тому же результату.
Например, при работе с немецкими названиями:
 alert( "ö" > "z" ); // true
	Юникод в HTML
Кстати, если мы знаем код символа в кодировке юникод, то можем добавить его в HTML, используя «числовую ссылку» (numeric character reference).
Для этого нужно написать сначала &#, затем код, и завершить точкой с запятой ';'. Например, символ 'а' в виде числовой ссылки: &#1072;.
Если код хотят дать в 16-ричной системе счисления, то начинают с &#x.
В юникоде есть много забавных и полезных символов, например, символ ножниц: ✂ (&#x2702;), дроби: ½ (&#xBD;) ¾ (&#xBE;) и другие. Их можно использовать вместо картинок в дизайне.



	Посимвольное сравнение
Сравнение строк работает лексикографически, иначе говоря, посимвольно.
Сравнение строк s1 и s2 обрабатывается по следующему алгоритму:
Сравниваются первые символы: s1[0] и s2[0]. Если они разные, то сравниваем их и, в зависимости от результата их сравнения, возвратить true или false. Если же они одинаковые, то…
Сравниваются вторые символы s1[1] и s2[1]
Затем третьи s1[2] и s2[2] и так далее, пока символы не будут наконец разными, и тогда какой символ больше – та строка и больше. Если же в какой-либо строке закончились символы, то считаем, что она меньше, а если закончились в обеих – они равны.
Спецификация языка определяет этот алгоритм более детально. Если же говорить простыми словами, смысл алгоритма в точности соответствует порядку, по которому имена заносятся в орфографический словарь.
	"Вася" > "Ваня" // true, т.к. начальные символы совпадают, а потом 'с' > 'н'
	"Дома" > "До" // true, т.к. начало совпадает, но в 1-й строке больше символов
Числа в виде строк сравниваются как строки
Бывает, что числа приходят в скрипт в виде строк, например как результат prompt. В этом случае результат их сравнения будет неверным:
	 alert( "2" > "14" ); // true, так как это строки, и для первых символов верно "2" > "1"
Если хотя бы один аргумент – не строка, то другой будет преобразован к числу:
	 alert( 2 > "14" ); // false


	 Правильное сравнение
Все современные браузеры, кроме IE10- (для которых нужно подключить библиотеку Intl.JS) поддерживают стандарт ECMA 402, поддерживающий сравнение строк на разных языках, с учётом их правил.
Способ использования:
	 var str = "Ёлки";
	alert( str.localeCompare("Яблони") ); // -1
Метод str1.localeCompare(str2) возвращает -1, если str1 < str2, 1, если str1 > str2 и 0, если они равны.
Более подробно про устройство этого метода можно будет узнать в статье Intl: интернационализация в JavaScript, когда это вам понадобится.







	Обьекты как ассоциативные массивы
Основные операции с объектами – это создание, получение и удаление свойств.
Для обращения к свойствам используется запись «через точку», вида объект.свойство, например:
	// при присвоении свойства в объекте автоматически создаётся "ящик"
	// с именем "name" и в него записывается содержимое 'Вася'
	person.name = 'Вася';
	person.age = 25; // запишем ещё одно свойство: с именем 'age' и значением 25
Удаление осуществляется оператором delete:
	delete person.age;
Иногда бывает нужно проверить, есть ли в объекте свойство с определенным ключом.
Для этого есть особый оператор: "in".
Его синтаксис: "prop" in obj, причем имя свойства – в виде строки, например:
	if ("name" in person) {
	  alert( "Свойство name существует!" );
	}
Впрочем, чаще используется другой способ – сравнение значения с undefined.
Дело в том, что в JavaScript можно обратиться к любому свойству объекта, даже если его нет.
Ошибки не будет.
Но если свойство не существует, то вернется специальное значение undefined:
 	var person = {};
	alert( person.lalala ); // undefined, нет свойства с ключом lalala
Таким образом мы можем легко проверить существование свойства – получив его и сравнив с undefined:
	 var person = {
	  name: "Василий"
	};

	alert( person.lalala === undefined ); // true, свойства нет
	alert( person.name === undefined ); // false, свойство есть

		Разница между проверками in и === undefined
Есть два средства для проверки наличия свойства в объекте: первое – оператор in, второе – получить его и сравнить с undefined.
Они почти идентичны, но есть одна небольшая разница.
Дело в том, что технически возможно, что свойство есть, а его значением является undefined:
	var obj = {};
	obj.test = undefined; // добавили свойство со значением undefined

	// проверим наличие свойств test и заведомо отсутствующего blabla
	alert( obj.test === undefined ); // true
	alert( obj.blabla === undefined ); // true
…При этом, как видно из кода, при простом сравнении наличие такого свойства будет неотличимо от его отсутствия.
Но оператор in гарантирует правильный результат:
	var obj = {};
	obj.test = undefined;

	alert( "test" in obj ); // true
	alert( "blabla" in obj ); // false
Как правило, в коде мы не будем присваивать undefined, чтобы корректно работали обе проверки. А в качестве значения, обозначающего неизвестность и неопределенность, будем использовать null.

	Доступ через квадратные скобки
Существует альтернативный синтаксис работы со свойствами, использующий квадратные скобки объект['свойство']:
	 var person = {};
	person['name'] = 'Вася'; // то же что и person.name = 'Вася'
Записи person['name'] и person.name идентичны, но квадратные скобки позволяют использовать в качестве имени свойства любую строку:
	 var person = {};
	person['любимый стиль музыки'] = 'Джаз';
Такое присвоение было бы невозможно «через точку», так интерпретатор после первого пробела подумает, что свойство закончилось, и далее выдаст ошибку:
	 person.любимый стиль музыки = 'Джаз'; // ??? ошибка
В обоих случаях, имя свойства обязано быть строкой. Если использовано значение другого типа – JavaScript приведет его к строке автоматически.
Квадратные скобки также позволяют обратиться к свойству, имя которого хранится в переменной:
	 var person = {};
	person.age = 25;
	var key = 'age';
	alert( person[key] ); // выведет person['age']
Вообще, если имя свойства хранится в переменной (var key = "age"), то единственный способ к нему обратиться – это квадратные скобки person[key].
Доступ через точку используется, если мы на этапе написания программы уже знаем название свойства. А если оно будет определено по ходу выполнения, например, введено посетителем и записано в переменную, то единственный выбор – квадратные скобки.




Обьекты: перебор свойств:
Для перебора всех свойств из объекта используется цикл по свойствам for..in. Эта синтаксическая конструкция отличается от рассмотренного ранее цикла for(;;).
for..in
Синтаксис:
	for (key in obj) {
	  /* ... делать что-то с obj[key] ... */
	}
Вспомогательную переменную key можно объявить прямо в цикле:
	for (var key in menu) {
	  // ...
	}

В каком порядке перебираются свойства?
Для примера, рассмотрим объект, который задаёт список опций для выбора страны:
	var codes = {
	  // телефонные коды в формате "код страны": "название"
	  "7": "Россия",
	  "38": "Украина",
	  // ..,
	  "1": "США"
	};
Здесь мы предполагаем, что большинство посетителей из России, и поэтому начинаем с 7, это зависит от проекта.
При выборе телефонного кода мы хотели бы предлагать варианты, начиная с первого. Обычно на основе списка генерируется select, но здесь нам важно не это, а важно другое.
Правда ли, что при переборе for(key in codes) ключи key будут перечислены именно в том порядке, в котором заданы?
По стандарту – нет. Но некоторое соглашение об этом, всё же, есть.
Соглашение говорит, что если имя свойства – нечисловая строка, то такие ключи всегда перебираются в том же порядке, в каком присваивались. Так получилось по историческим причинам и изменить это сложно: поломается много готового кода.
С другой стороны, если имя свойства – число или числовая строка, то все современные браузеры сортируют такие свойства в целях внутренней оптимизации.
К примеру, рассмотрим объект с заведомо нечисловыми свойствами:

	var user = {
	  name: "Вася",
	  surname: "Петров"
	};
	user.age = 25;
	// порядок перебора соответствует порядку присвоения свойства
	for (var prop in user) {
	  alert( prop ); // name, surname, age
	}
А теперь – что будет, если перебрать объект с кодами?

	 var codes = {
	  // телефонные коды в формате "код страны": "название"
	  "7": "Россия",
	  "38": "Украина",
	  "1": "США"
	};

	for (var code in codes) alert( code ); // 1, 7, 38
При запуске этого кода в современном браузере мы увидим, что на первое место попал код США!
Нарушение порядка возникло, потому что ключи численные. Интерпретатор JavaScript видит, что строка на самом деле является числом и преобразует ключ в немного другой внутренний формат. Дополнительным эффектом внутренних оптимизаций является сортировка.
А что, если мы хотим, чтобы порядок был именно таким, какой мы задали?

Это возможно. Можно применить небольшой хак, который заключается в том, чтобы сделать все ключи нечисловыми, например, добавим в начало дополнительный символ '+':
	 var codes = {
	  "+7": "Россия",
	  "+38": "Украина",
	  "+1": "США"
	};

	for (var code in codes) {
	  var value = codes[code];
	  code = +code; // ..если нам нужно именно число, преобразуем: "+7" -> 7

	  alert( code + ": " + value ); // 7, 38, 1 во всех браузерах
	}

Если нужно, чтобы порядок перебора числовых ключей соответствовал их объявлению в объекте, то используют трюк: числовые ключи заменяют на похожие, но содержащие не только цифры. Например, добавляют в начало +, как описано в примере выше, а потом, в процессе обработки, преобразуют такие ключи в числа.








	Копирование
Обычные значения: строки, числа, булевы значения, null/undefined при присваивании переменных копируются целиком или, как говорят, «по значению».
	var message = "Привет!";
	var phrase = message;

	Копирование по ссылке
С объектами – всё не так.
В переменной, которой присвоен объект, хранится не сам объект, а «адрес его места в памяти», иными словами – «ссылка» на него.
	var user = {
	  name: "Вася"
	};
Внимание: объект – вне переменной. В переменной – лишь «адрес» (ссылка) для него.
При копировании переменной с объектом – копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре.
Например:
	var user = { name: "Вася" }; // в переменной - ссылка
	var admin = user; // скопировали ссылку
Так как объект всего один, то изменения через любую переменную видны в других переменных:
	var user = { name: 'Вася' };
	var admin = user;
	admin.name = 'Петя'; // поменяли данные через admin
	alert(user.name); // 'Петя', изменения видны в user
Переменная с объектом как «ключ» к сейфу с данными
Ещё одна аналогия: переменная, в которую присвоен объект, на самом деле хранит не сами данные, а ключ к сейфу, где они хранятся.
При копировании её, получается что мы сделали копию ключа, но сейф по-прежнему один.

	Клонирование объектов
Иногда, на практике – очень редко, нужно скопировать объект целиком, создать именно полную независимую копию, «клон» объекта.
Что ж, можно сделать и это. Для этого нужно пройти по объекту, достать данные и скопировать на уровне примитивов.
Примерно так:
	var user = {
	  name: "Вася",
	  age: 30
	};

	var clone = {}; // новый пустой объект

	// скопируем в него все свойства user
	for (var key in user) {
	  clone[key] = user[key];
	}

	// теперь clone - полностью независимая копия
	clone.name = "Петя"; // поменяли данные в clone

	alert( user.name ); // по-прежнему "Вася"
В этом коде каждое свойство объекта user копируется в clone. Если предположить, что они примитивны, то каждое скопируется по значению и мы как раз получим полный клон.
Если же свойства объектов, в свою очередь, могут хранить ссылки на другие объекты, то нужно обойти такие подобъекты и тоже склонировать их. Это называют «глубоким» клонированием.

При «раскрытии» свойств объекта в консоли – браузер всегда выводит их текущие (на момент раскрытия) значения.
Так происходит именно потому, что вывод не делает «копию» текущего содержимого, а сохраняет лишь ссылку на объект. Запомните эту особенность консоли, в будущем, при отладке скриптов у вас не раз возникнет подобная ситуация.




	Массивы
pop
Удаляет последний элемент из массива и возвращает его:
	 var fruits = ["Яблоко", "Апельсин", "Груша"];
	alert( fruits.pop() ); // удалили "Груша"
	alert( fruits ); // Яблоко, Апельсин

push
Добавляет элемент в конец массива:
	 var fruits = ["Яблоко", "Апельсин"];
	fruits.push("Груша");
	alert( fruits ); // Яблоко, Апельсин, Груша
Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....

shift
Удаляет из массива первый элемент и возвращает его:
	var fruits = ["Яблоко", "Апельсин", "Груша"];
	alert( fruits.shift() ); // удалили Яблоко
	alert( fruits ); // Апельсин, Груша

unshift
Добавляет элемент в начало массива:
	var fruits = ["Апельсин", "Груша"];
	fruits.unshift('Яблоко');
	alert( fruits ); // Яблоко, Апельсин, Груша

Методы push и unshift могут добавлять сразу по несколько элементов:
	 var fruits = ["Яблоко"];
	fruits.push("Апельсин", "Персик");
	fruits.unshift("Ананас", "Лимон");
	// результат: ["Ананас", "Лимон", "Яблоко", "Апельсин", "Персик"]
	alert( fruits );


Массив – это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length.
Так как это объект, то в функцию он передаётся по ссылке

Ещё одно следствие – можно присваивать в массив любые свойства.
Например:
	var fruits = []; // создать массив
	fruits[99999] = 5; // присвоить свойство с любым номером
	fruits.age = 25; // назначить свойство со строковым именем
… Но массивы для того и придуманы в JavaScript, чтобы удобно работать именно с упорядоченными, нумерованными данными. Для этого в них существуют специальные методы и свойство length.
Как правило, нет причин использовать массив как обычный объект, хотя технически это и возможно.

Влияние на быстродействие
Методы push/pop выполняются быстро, а shift/unshift – медленно.

//array-speed.png from arrays-images

Чтобы понять, почему работать с концом массива – быстрее, чем с его началом, разберём подробнее происходящее при операции:
		fruits.shift(); // убрать 1 элемент с начала
При этом, так как все элементы находятся в своих ячейках, просто удалить элемент с номером 0 недостаточно. Нужно еще и Переместитьить остальные элементы на их новые индексы.
Операция shift должна выполнить целых три действия:
	1 -Удалить нулевой элемент.
	2 -Переместить все свойства влево, с индекса 1 на 0, с 2 на 1 и так далее.
	3 -Обновить свойство length.

//array-shift.png

Чем больше элементов в массиве, тем дольше их перемещать, это много операций с памятью.
Аналогично работает unshift: чтобы добавить элемент в начало массива, нужно сначала перенести вправо, в увеличенные индексы, все существующие.
А что же с push/pop? Им как раз перемещать ничего не надо. Для того, чтобы удалить элемент, метод pop очищает ячейку и уменьшает значение length.
Действия при операции:
		fruits.pop(); // убрать 1 элемент с конца

//array-pop.png

Перемещать при pop не требуется, так как прочие элементы после этой операции остаются на тех же индексах.
Аналогично работает push.


		Не используйте for..in для массивов
Так как массив является объектом, то возможен и вариант for..in:
	var arr = ["Яблоко", "Апельсин", "Груша"];
	for (var key in arr) {
	  alert( arr[key] ); // Яблоко, Апельсин, Груша
	}
Недостатки этого способа:
1 -Цикл for..in выведет все свойства объекта, а не только цифровые.
		В браузере, при работе с объектами страницы, встречаются коллекции элементов, которые по виду как массивы, но имеют дополнительные нецифровые свойства. При переборе таких «похожих на массив» коллекций через for..in эти свойства будут выведены, а они как раз не нужны.
		Бывают и библиотеки, которые предоставляют такие коллекции. Классический for надёжно выведет только цифровые свойства, что обычно и требуется.
2 -Цикл for (var i=0; i<arr.length; i++) в современных браузерах выполняется в 10-100 раз быстрее. Казалось бы, по виду он 				сложнее, но браузер особым образом оптимизирует такие циклы.
	Если коротко: цикл for(var i=0; i<arr.length...) надёжнее и быстрее.


		Особенности работы length
Встроенные методы для работы с массивом автоматически обновляют его длину length.
Длина length – не количество элементов массива, а последний индекс + 1.
Так уж оно устроено.
Это легко увидеть на следующем примере:
	var arr = [];
	arr[1000] = true;
	alert(arr.length); // 1001
Кстати, если у вас элементы массива нумеруются случайно или с большими пропусками, то стоит подумать о том, чтобы использовать обычный объект. Массивы предназначены именно для работы с непрерывной упорядоченной коллекцией элементов.


		Используем length для укорачивания массива
Обычно нам не нужно самостоятельно менять length… Но есть один фокус, который можно провернуть.
При уменьшении length массив укорачивается.
Причем этот процесс необратимый, т.е. даже если потом вернуть length обратно – значения не восстановятся:
	 var arr = [1, 2, 3, 4, 5];
	arr.length = 2; // укоротить до 2 элементов
	alert( arr ); // [1, 2]
	arr.length = 5; // вернуть length обратно, как было
	alert( arr[3] ); // undefined: значения не вернулись
Самый простой способ очистить массив – это arr.length=0.


!!! Современные интерпретаторы стараются оптимизировать их и хранить в памяти не в виде хэш-таблицы, а в виде непрерывной области памяти, по которой легко пробежаться от начала до конца.



		Массивы: методы
	Метод split
Ситуация из реальной жизни. Мы пишем сервис отсылки сообщений и посетитель вводит имена тех, кому его отправить: Маша, Петя, Марина, Василий.... Но нам-то гораздо удобнее работать с массивом имен, чем с одной строкой.
К счастью, есть метод split(s), который позволяет превратить строку в массив, разбив ее по разделителю s. В примере ниже таким разделителем является строка из запятой и пробела.
	 var names = 'Маша, Петя, Марина, Василий';
	var arr = names.split(', ');
	for (var i = 0; i < arr.length; i++) {
	  alert( 'Вам сообщение ' + arr[i] );
	}

		Второй аргумент split
У метода split есть необязательный второй аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано – остаток массива будет отброшен:
    alert( "a,b,c,d".split(',', 2) ); // a,b

		Разбивка по буквам
Вызов split с пустой строкой разобьёт по буквам:
	 var str = "тест";
	alert( str.split('') ); // т,е,с,т


	Метод join
Вызов arr.join(str) делает в точности противоположное split. Он берет массив и склеивает его в строку, используя str как разделитель.
Например:
	 var arr = ['Маша', 'Петя', 'Марина', 'Василий'];
	var str = arr.join(';');
	alert( str ); // Маша;Петя;Марина;Василий

		new Array + join = Повторение строки
Код для повторения строки 3 раза:
	alert( new Array(4).join("ля") ); // ляляля
Как видно, new Array(4) делает массив без элементов длины 4, который join объединяет в строку, вставляя между его элементами строку "ля".
В результате, так как элементы пусты, получается повторение строки. Такой вот небольшой трюк.


	Удаление из массива
Так как массивы являются объектами, то для удаления ключа можно воспользоваться обычным delete:
	 var arr = ["Я", "иду", "домой"];
	delete arr[1]; // значение с индексом 1 удалено
	// теперь arr = ["Я", undefined, "домой"];
	alert( arr[1] ); // undefined
Да, элемент удален из массива, но не так, как нам этого хочется. Образовалась «дырка».
Это потому, что оператор delete удаляет пару «ключ-значение». Это – все, что он делает. Обычно же при удалении из массива мы хотим, чтобы оставшиеся элементы сдвинулись и заполнили образовавшийся промежуток.

Поэтому для удаления используются специальные методы: из начала – shift, с конца – pop, а из середины – splice, с которым мы сейчас познакомимся.


	Метод splice
Метод splice – это универсальный раскладной нож для работы с массивами. Умеет все: удалять элементы, вставлять элементы, заменять элементы – по очереди и одновременно.

Его синтаксис:
arr.splice(index[, deleteCount, elem1, ..., elemN])
Удалить deleteCount элементов, начиная с номера index, а затем вставить elem1, ..., elemN на их место. Возвращает массив из удалённых элементов.
Этот метод проще всего понять, рассмотрев примеры.

Начнём с удаления:
	var arr = ["Я", "изучаю", "JavaScript"];
	arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
	alert( arr ); //  осталось ["Я", "JavaScript"]

В следующем примере мы удалим 3 элемента и вставим другие на их место:
    var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
	// удалить 3 первых элемента и добавить другие вместо них
	arr.splice(0, 3, "Мы", "изучаем")
	alert( arr ) // теперь ["Мы", "изучаем", "JavaScript"]

Здесь видно, что splice возвращает массив из удаленных элементов:
	var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
	// удалить 2 первых элемента
	var removed = arr.splice(0, 2);
	alert( removed ); // "Я", "сейчас" <-- array of removed elements

Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:
	 var arr = ["Я", "изучаю", "JavaScript"];
	// с позиции 2
	// удалить 0
	// вставить "сложный", "язык"
	arr.splice(2, 0, "сложный", "язык");
	alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"

Допускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца:
	var arr = [1, 2, 5]
	// начиная с позиции индексом -1 (перед последним элементом)
	// удалить 0 элементов,
	// затем вставить числа 3 и 4
	arr.splice(-1, 0, 3, 4);
	alert( arr ); // результат: 1,2,3,4,5



	Метод slice
Метод slice(begin, end) копирует участок массива от begin до end, не включая end. Исходный массив при этом не меняется.
Например:
	 var arr = ["Почему", "надо", "учить", "JavaScript"];
	var arr2 = arr.slice(1, 3); // элементы 1, 2 (не включая 3)
	alert( arr2 ); // надо, учить

Аргументы ведут себя так же, как и в строковом slice:
Если не указать end – копирование будет до конца массива:
	 var arr = ["Почему", "надо", "учить", "JavaScript"];
	alert( arr.slice(1) ); // взять все элементы, начиная с номера 1

Можно использовать отрицательные индексы, они отсчитываются с конца:
var arr2 = arr.slice(-2); // копировать от 2-го элемента с конца и дальше

Если вообще не указать аргументов – скопируется весь массив:
	var fullCopy = arr.slice();

	Совсем как в строках
Синтаксис метода slice одинаков для строк и для массивов. Тем проще его запомнить.


	Сортировка, метод sort(fn)
Метод sort() сортирует массив на месте. Например:
	var arr = [ 1, 2, 15 ];
	arr.sort();
	alert( arr );  // 1, 15, 2
Не заметили ничего странного в этом примере?
Порядок стал 1, 15, 2, это точно не сортировка чисел. Почему?
Это произошло потому, что по умолчанию sort сортирует, преобразуя элементы к строке.
Поэтому и порядок у них строковый, ведь "2" > "15".


Свой порядок сортировки
Для указания своего порядка сортировки в метод arr.sort(fn) нужно передать функцию fn от двух элементов, которая умеет сравнивать их.
Внутренний алгоритм функции сортировки умеет сортировать любые массивы – апельсинов, яблок, пользователей, и тех и других и третьих – чего угодно. Но для этого ему нужно знать, как их сравнивать. Эту роль и выполняет fn.
Если эту функцию не указать, то элементы сортируются как строки.

Например, укажем эту функцию явно, отсортируем элементы массива как числа:
	 function compareNumeric(a, b) {
	  if (a > b) return 1;
	  if (a < b) return -1;
	}
	var arr = [ 1, 2, 15 ];
	arr.sort(compareNumeric);
	alert(arr);  // 1, 2, 15

Обратите внимание, мы передаём в sort() именно саму функцию compareNumeric, без вызова через скобки. Был бы ошибкой следующий код:
    arr.sort( compareNumeric() );  // не сработает
Как видно из примера выше, функция, передаваемая sort, должна иметь два аргумента.
Алгоритм сортировки, встроенный в JavaScript, будет передавать ей для сравнения элементы массива. Она должна возвращать:
Положительное значение, если a > b,
Отрицательное значение, если a < b,
Если равны – можно 0, но вообще – не важно, что возвращать, если их взаимный порядок не имеет значения.

	Алгоритм сортировки
В методе sort, внутри самого интерпретатора JavaScript, реализован универсальный алгоритм сортировки. Как правило, это ««быстрая сортировка»», дополнительно оптимизированная для небольших массивов.
Он решает, какие пары элементов и когда сравнивать, чтобы отсортировать побыстрее. Мы даём ему функцию – способ сравнения, дальше он вызывает её сам.
Кстати, те значения, с которыми sort вызывает функцию сравнения, можно увидеть, если вставить в неё alert:
	 [1, -2, 15, 2, 0, 8].sort(function(a, b) {
	  alert( a + " <> " + b );
	});

	Сравнение compareNumeric в одну строку
Функцию compareNumeric для сравнения элементов-чисел можно упростить до одной строчки.
	function compareNumeric(a, b) {
	  return a - b;
	}
Эта функция вполне подходит для sort, так как возвращает положительное число, если a > b, отрицательное, если наоборот, и 0, если числа равны.



	reverse
Метод arr.reverse() меняет порядок элементов в массиве на обратный.
	 var arr = [1, 2, 3];
	arr.reverse();
	alert( arr ); // 3,2,1


		concat
Метод arr.concat(value1, value2, … valueN) создаёт новый массив, в который копируются элементы из arr, а также value1, value2, ... valueN.
Например:
	var arr = [1, 2];
	var newArr = arr.concat(3, 4);
	alert( newArr ); // 1,2,3,4

У concat есть одна забавная особенность.
Если аргумент concat – массив, то concat добавляет элементы из него.
Например:
	var arr = [1, 2];
	var newArr = arr.concat([3, 4], 5); // то же самое, что arr.concat(3,4,5)
	alert( newArr ); // 1,2,3,4,5



	indexOf/lastIndexOf
Эти методы не поддерживаются в IE8-. Для их поддержки подключите библиотеку ES5-shim.
Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или -1, если его нет.
Поиск начинается с номера fromIndex, если он указан. Если нет – с начала массива.

Для поиска используется строгое сравнение ===.

Например:
	 var arr = [1, 0, false];
	alert( arr.indexOf(0) ); // 1
	alert( arr.indexOf(false) ); // 2
	alert( arr.indexOf(null) ); // -1
Как вы могли заметить, по синтаксису он полностью аналогичен методу indexOf для строк.
Метод «arr.lastIndexOf(searchElement[, fromIndex])» ищет справа-налево: с конца массива или с номера fromIndex, если он указан.

Методы indexOf/lastIndexOf осуществляют поиск перебором
Если нужно проверить, существует ли значение в массиве – его нужно перебрать. Только так. Внутренняя реализация indexOf/lastIndexOf осуществляет полный перебор, аналогичный циклу for по массиву. Чем длиннее массив, тем дольше он будет работать.

	Коллекция уникальных элементов
Рассмотрим задачу – есть коллекция строк, и нужно быстро проверять: есть ли в ней какой-то элемент. Массив для этого не подходит из-за медленного indexOf. Но подходит объект! Доступ к свойству объекта осуществляется очень быстро, так что можно сделать все элементы ключами объекта и проверять, есть ли уже такой ключ.

Например, организуем такую проверку для коллекции строк "div", "a" и "form":
	var store = {}; // объект для коллекции
	var items = ["div", "a", "form"];
	for (var i = 0; i < items.length; i++) {
	  var key = items[i]; // для каждого элемента создаём свойство
	  store[key] = true; // значение здесь не важно
	}
Теперь для проверки, есть ли ключ key, достаточно выполнить if (store[key]). Если есть – можно использовать значение, если нет – добавить.

Такое решение работает только со строками, но применимо к любым элементам, для которых можно вычислить строковый «уникальный ключ».



Object.keys(obj) возвращает массив свойств объекта.
	var user = {
	  name: "Петя",
	  age: 30
	}
	var keys = Object.keys(user);
	alert( keys ); // name, age



		Массив: перебирающие методы
	forEach
Метод «arr.forEach(callback[, thisArg])» используется для перебора массива.
Он для каждого элемента массива вызывает функцию callback.
Этой функции он передаёт три параметра callback(item, i, arr):
item – очередной элемент массива.
i – его номер.
arr – массив, который перебирается.
Например:
	 var arr = ["Яблоко", "Апельсин", "Груша"];
	arr.forEach(function(item, i, arr) {
	  alert( i + ": " + item + " (массив:" + arr + ")" );
	});
Второй, необязательный аргумент forEach позволяет указать контекст this для callback. Мы обсудим его в деталях чуть позже, сейчас он нам не важен.
Метод forEach ничего не возвращает, его используют только для перебора, как более «элегантный» вариант, чем обычный цикл for.


	filter
Метод «arr.filter(callback[, thisArg])» используется для фильтрации массива через функцию.
Он создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true.
Например:
	var arr = [1, -1, 2, -2, 3];
	var positiveArr = arr.filter(function(number) {
	  return number > 0;
	});
	alert( positiveArr ); // 1,2,3


	map
Метод «arr.map(callback[, thisArg])» используется для трансформации массива.
Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr.
Например:
	var names = ['HTML', 'CSS', 'JavaScript'];
	var nameLengths = names.map(function(name) {
	  return name.length;
	});
	// получили массив с длинами
	alert( nameLengths ); // 4,3,10


	every/some
Эти методы используются для проверки массива.
Метод «arr.every(callback[, thisArg])» возвращает true, если вызов callback вернёт true для каждого элемента arr.
Метод «arr.some(callback[, thisArg])» возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr.
 
	var arr = [1, -1, 2, -2, 3];
	function isPositive(number) {
	  return number > 0;
	}
	alert( arr.every(isPositive) ); // false, не все положительные
	alert( arr.some(isPositive) ); // true, есть хоть одно положительное



	reduce/reduceRight
Метод «arr.reduce(callback[, initialValue])» используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.
Это один из самых сложных методов для работы с массивами. Но его стоит освоить, потому что временами с его помощью можно в несколько строк решить задачу, которая иначе потребовала бы в разы больше места и времени.
Метод reduce используется для вычисления на основе массива какого-либо единого значения, иначе говорят «для свёртки массива». Чуть далее мы разберём пример для вычисления суммы.
Он применяет функцию callback по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат.

Аргументы функции callback(previousValue, currentItem, index, arr):

previousValue – последний результат вызова функции, он же «промежуточный результат».
currentItem – текущий элемент массива, элементы перебираются по очереди слева-направо.
index – номер текущего элемента.
arr – обрабатываемый массив.
Кроме callback, методу можно передать «начальное значение» – аргумент initialValue. Если он есть, то на первом вызове значение previousValue будет равно initialValue, а если у reduce нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.

Проще всего понять работу метода reduce на примере.
Например, в качестве «свёртки» мы хотим получить сумму всех элементов массива.
Вот решение в одну строку:
	 var arr = [1, 2, 3, 4, 5]
	// для каждого элемента массива запустить функцию,
	// промежуточный результат передавать первым аргументом далее
	var result = arr.reduce(function(sum, current) {
	  return sum + current;
	}, 0);
	alert( result ); // 15
Разберём, что в нём происходит.
При первом запуске sum – исходное значение, с которого начинаются вычисления, равно нулю (второй аргумент reduce).
Сначала анонимная функция вызывается с этим начальным значением и первым элементом массива, результат запоминается и передаётся в следующий вызов, уже со вторым аргументом массива, затем новое значение участвует в вычислениях с третьим аргументом и так далее.

sum	current	результат
первый вызов	0	1	1
второй вызов	1	2	3
третий вызов	3	3	6
четвёртый вызов	6	4	10
пятый вызов		10	5	15
Как видно, результат предыдущего вызова передаётся в первый аргумент следующего.

Кстати, полный набор аргументов функции для reduce включает в себя function(sum, current, i, array), то есть номер текущего вызова i и весь массив arr, но здесь в них нет нужды.

Посмотрим, что будет, если не указать initialValue в вызове arr.reduce:
	 var arr = [1, 2, 3, 4, 5]
	// убрали 0 в конце
	var result = arr.reduce(function(sum, current) {
	  return sum + current
	});
	alert( result ); // 15
Результат – точно такой же! Это потому, что при отсутствии initialValue в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.

Таблица вычислений будет такая же, за вычетом первой строки.
Метод arr.reduceRight работает аналогично, но идёт по массиву справа-налево.

