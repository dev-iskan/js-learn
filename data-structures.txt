Все значения в JavaScript, за исключением null и undefined, содержат набор вспомогательных функций и значений, доступных «через точку».
Такие функции называют «методами», а значения – «свойствами». Здесь мы рассмотрим основы использования свойств и методов.

Числа
Все числа в JavaScript, как целые так и дробные, имеют тип Number и хранятся в 64-битном формате IEEE-754, также известном как «double precision».

	Способы записи
В JavaScript можно записывать числа не только в десятичной, но и в шестнадцатеричной (начинается с 0x) системе счисления:
 	alert( 0xFF ); // 255 в шестнадцатиричной системе
Также доступна запись в «научном формате» (ещё говорят «запись с плавающей точкой»), который выглядит как <число>e<количество нулей>.
Например, 1e3 – это 1 с 3 нулями, то есть 1000.
	 // еще пример научной формы: 3 с 5 нулями
	alert( 3e5 ); // 300000
Если количество нулей отрицательно, то число сдвигается вправо за десятичную точку, так что получается десятичная дробь:
	 // здесь 3 сдвинуто 5 раз вправо, за десятичную точку.
	alert( 3e-5 ); // 0.00003  <-- 5 нулей, включая начальный ноль

	Деление на ноль, Infinity
Представьте, что вы собираетесь создать новый язык… Люди будут называть его «JavaScript» (или «LiveScript»… неважно).
Что должно происходить при попытке деления на ноль?
Как правило, ошибка в программе… Во всяком случае, в большинстве языков программирования это именно так.
Но создатель JavaScript решил пойти математически правильным путем. Ведь чем меньше делитель, тем больше результат. При делении на очень-очень маленькое число должно получиться очень большое. В математическом анализе это описывается через пределы, и если подразумевать предел, то в качестве результата деления на 0 мы получаем «бесконечность», которая обозначается символом ∞ (в JavaScript Infinity).
	 alert( 1 / 0 ); // Infinity
	alert( 12345 / 0 ); // Infinity
Infinity – особенное численное значение, которое ведет себя в точности как математическая бесконечность ∞.
Infinity больше любого числа.
Добавление к бесконечности не меняет её.
	 alert( Infinity > 1234567890 ); // true
	alert( Infinity + 5 == Infinity ); // true
Бесконечность можно присвоить и в явном виде: var x = Infinity.
Бывает и минус бесконечность -Infinity:
 	alert( -1 / 0 ); // -Infinity
Бесконечность можно получить также, если сделать ну очень большое число, для которого количество разрядов в двоичном представлении не помещается в соответствующую часть стандартного 64-битного формата, например:
	 alert( 1e500 ); // Infinity

	NaN
Если математическая операция не может быть совершена, то возвращается специальное значение NaN (Not-A-Number).
Например, деление 0/0 в математическом смысле неопределено, поэтому его результат NaN:
 	alert( 0 / 0 ); // NaN
Значение NaN используется для обозначения математической ошибки и обладает следующими свойствами:
	Значение NaN – единственное в своем роде, которое не равно ничему, включая себя.
Следующий код ничего не выведет:
	 if (NaN == NaN) alert( "==" ); // Ни один вызов
	if (NaN === NaN) alert( "===" ); // не сработает
Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает true, если получилось NaN, и false – для любого другого значения.
	 var n = 0 / 0;
	alert( isNaN(n) ); // true
	alert( isNaN("12") ); // false, строка преобразовалась к обычному числу 12
Значение NaN «прилипчиво». Любая операция с NaN возвращает NaN.
 	alert( NaN + 1 ); // NaN
Если аргумент isNaN – не число, то он автоматически преобразуется к числу.
Забавный способ проверки на NaN
Отсюда вытекает забавный способ проверки значения на NaN: можно проверить значение на равенство самому себе, если не равно – то NaN:
	 var n = 0 / 0;
	if (n !== n) alert( 'n = NaN!' );
Это работает, но для наглядности лучше использовать isNaN(n).
	Математические операции в JS безопасны
	Никакие математические операции в JavaScript не могут привести к ошибке или «обрушить» программу.
	В худшем случае результат будет NaN.


	isFinite(n)
Итак, в JavaScript есть обычные числа и три специальных числовых значения: NaN, Infinity и -Infinity.
Тот факт, что они, хоть и особые, но числа, демонстрируется работой оператора +:
	var value = prompt("Введите Infinity", 'Infinity');
	var number = +value;
	alert( number ); // Infinity, плюс преобразовал строку "Infinity" к такому "числу"
Обычно если мы хотим от посетителя получить число, то Infinity или NaN нам не подходят. Для того чтобы отличить «обычные» числа от таких специальных значений, существует функция isFinite.
Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity:
	 alert( isFinite(1) ); // true
	alert( isFinite(Infinity) ); // false
	alert( isFinite(NaN) ); // false


	Преобразование к числу
Большинство арифметических операций и математических функций преобразуют значение в число автоматически.
Для того чтобы сделать это явно, обычно перед значением ставят унарный плюс '+':
	 var s = "12.34";
	alert( +s ); // 12.34
При этом, если строка не является в точности числом, то результат будет NaN:
	 alert( +"12test" ); // NaN
Единственное исключение – пробельные символы в начале и в конце строки, которые игнорируются:
	 alert( +"  -12" ); // -12
	alert( +" \n34  \n" ); // 34, перевод строки \n является пробельным символом
	alert( +"" ); // 0, пустая строка становится нулем
	alert( +"1 2" ); // NaN, пробел посередине числа - ошибка
Аналогичным образом происходит преобразование и в других математических операторах и функциях:
 	alert( '12.34' / "-2" ); // -6.17


 	Мягкое преобразование: parseInt и parseFloat
В мире HTML/CSS многие значения не являются в точности числами. Например метрики CSS: 10pt или -12px.
Оператор '+' для таких значений возвратит NaN:
	 alert(+"12px") // NaN
Для удобного чтения таких значений существует функция parseInt:
 	alert( parseInt('12px') ); // 12
Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.
При возникновении ошибки возвращается число, которое получилось. Функция parseInt читает из строки целое число, а parseFloat – дробное.
	 alert( parseInt('12px') ) // 12, ошибка на символе 'p'
	alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке
Конечно, существуют ситуации, когда parseInt/parseFloat возвращают NaN. Это происходит при ошибке на первом же символе:
 	alert( parseInt('a123') ); // NaN
Функция parseInt также позволяет указать систему счисления, то есть считывать числа, заданные в шестнадцатиричной и других системах счисления:
 	alert( parseInt('FF', 16) ); // 255


 	Проверка на число
Для проверки строки на число можно использовать функцию isNaN(str).
Она преобразует строку в число аналогично +, а затем вернёт true, если это NaN, то есть если преобразование не удалось:
	 var x = prompt("Введите значение", "-11.5");
	if (isNaN(x)) {
	  alert( "Строка преобразовалась в NaN. Не число" );
	} else {
	  alert( "Число" );
	}
Однако, у такой проверки есть две особенности:
Пустая строка и строка из пробельных символов преобразуются к 0, поэтому считаются числами.
Если применить такую проверку не к строке, то могут быть сюрпризы, в частности isNaN посчитает числами значения false, true, null, так как они хотя и не числа, но преобразуются к ним.
	 alert( isNaN(null) ); //  false - не NaN, т.е. "число"
	alert( isNaN("\n  \n") ); //  false - не NaN, т.е. "число"
Если такое поведение допустимо, то isNaN – приемлемый вариант.
Если же нужна действительно точная проверка на число, которая не считает числом строку из пробелов, логические и специальные значения, а также отсекает Infinity – используйте следующую функцию isNumeric:
	function isNumeric(n) {
	  return !isNaN(parseFloat(n)) && isFinite(n);
	}
Разберёмся, как она работает. Начнём справа.
Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не Infinity/-Infinity/NaN.
Таким образом, правая часть отсеет заведомо не-числа, но оставит такие значения как true/false/null и пустую строку '', так как они корректно преобразуются в числа.
Для их проверки нужна левая часть. Вызов parseFloat(true/false/null/'') вернёт NaN для этих значений.
Так устроена функция parseFloat: она преобразует аргумент к строке, то есть true/false/null становятся "true"/"false"/"null", а затем считывает из неё число, при этом пустая строка даёт NaN.
В результате отсеивается всё, кроме строк-чисел и обычных чисел.


	toString(система счисления)
Как показано выше, числа можно записывать не только в 10-ричной, но и в 16-ричной системе. Но бывает и противоположная задача: получить 16-ричное представление числа. Для этого используется метод toString(основание системы), например:
	 var n = 255;
	alert( n.toString(16) ); // ff
В частности, это используют для работы с цветовыми значениями в браузере, вида #AABBCC.
Основание может быть любым от 2 до 36.
Основание 2 бывает полезно для отладки побитовых операций:
	 var n = 4;
	alert( n.toString(2) ); // 100
Основание 36 (по количеству букв в английском алфавите – 26, вместе с цифрами, которых 10) используется для того, чтобы «кодировать» число в виде буквенно-цифровой строки. В этой системе счисления сначала используются цифры, а затем буквы от a до z:
	 var n = 1234567890;
	alert( n.toString(36) ); // kf12oi
При помощи такого кодирования можно «укоротить» длинный цифровой идентификатор, например чтобы выдать его в качестве URL.


	Округление
Одна из самых частых операций с числом – округление. В JavaScript существуют целых 3 функции для этого.
Math.floor
Округляет вниз
Math.ceil
Округляет вверх
Math.round
Округляет до ближайшего целого
		 alert( Math.floor(3.1) );  // 3
		alert( Math.ceil(3.1) );   // 4
		alert( Math.round(3.1) );  // 3
	Округление битовыми операторами
Битовые операторы делают любое число 32-битным целым, обрезая десятичную часть.
В результате побитовая операция, которая не изменяет число, например, двойное битовое НЕ – округляет его:
 	alert( ~~12.3 ); // 12
Любая побитовая операция такого рода подойдет, например XOR (исключающее ИЛИ, "^") с нулем:
	 alert( 12.3 ^ 0 ); // 12
	alert( 1.2 + 1.3 ^ 0 ); // 2, приоритет ^ меньше, чем +
Это удобно в первую очередь тем, что легко читается и не заставляет ставить дополнительные скобки как Math.floor(...):
	var x = a * b / c ^ 0; // читается как "a * b / c и округлить"



	Округление до заданной точности
Для округления до нужной цифры после запятой можно умножить и поделить на 10 с нужным количеством нулей. Например, округлим 3.456 до 2-го знака после запятой:
	 var n = 3.456;
	alert( Math.round(n * 100) / 100 ); // 3.456 -> 345.6 -> 346 -> 3.46
Таким образом можно округлять число и вверх и вниз.


	num.toFixed(precision)
Существует также специальный метод num.toFixed(precision), который округляет число num до точности precision и возвращает результат в виде строки:
	 var n = 12.34;
	alert( n.toFixed(1) ); // "12.3"
Округление идёт до ближайшего значения, аналогично Math.round:
	 var n = 12.36;
	alert( n.toFixed(1) ); // "12.4"
Итоговая строка, при необходимости, дополняется нулями до нужной точности:
	 var n = 12.34;
	alert( n.toFixed(5) ); // "12.34000", добавлены нули до 5 знаков после запятой
Если нам нужно именно число, то мы можем получить его, применив '+' к результату n.toFixed(..):
		 var n = 12.34;
		alert( +n.toFixed(5) ); // 12.34
	Метод toFixed не эквивалентен Math.round!
Например, произведём округление до одного знака после запятой с использованием двух способов: toFixed и Math.round с умножением и делением:
	 var price = 6.35;
	alert( price.toFixed(1) ); // 6.3
	alert( Math.round(price * 10) / 10 ); // 6.4
Как видно результат разный! Вариант округления через Math.round получился более корректным, так как по общепринятым правилам 5 округляется вверх. А toFixed может округлить его как вверх, так и вниз.
	Во внутреннем двоичном представлении 6.35 является бесконечной двоичной дробью. Хранится она с потерей точности… А впрочем, посмотрим сами:
	 alert( 6.35.toFixed(20) ); // 6.34999999999999964473
	Интерпретатор видит число как 6.34..., поэтому и округляет вниз.


	Неточные вычисления
Запустите этот пример:
 	alert( 0.1 + 0.2 == 0.3 );
Запустили? Если нет – все же сделайте это.
Ок, вы запустили его. Он вывел false. Результат несколько странный, не так ли? Возможно, ошибка в браузере? Поменяйте браузер, запустите еще раз.
Хорошо, теперь мы можем быть уверены: 0.1 + 0.2 это не 0.3. Но тогда что же это?
 	alert( 0.1 + 0.2 ); // 0.30000000000000004
Как видите, произошла небольшая вычислительная ошибка, результат сложения 0.1 + 0.2 немного больше, чем 0.3.
 	alert( 0.1 + 0.2 > 0.3 ); // true
Всё дело в том, что в стандарте IEEE 754 на число выделяется ровно 8 байт(=64 бита), не больше и не меньше.
Число 0.1 (одна десятая) записывается просто в десятичном формате. Но в двоичной системе счисления это бесконечная дробь, так как единица на десять в двоичной системе так просто не делится. Также бесконечной дробью является 0.2 (=2/10).
Двоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность. Её даже можно увидеть:
 	alert( 0.1.toFixed(20) ); // 0.10000000000000000555
Когда мы складываем 0.1 и 0.2, то две неточности складываются, получаем незначительную, но всё же ошибку в вычислениях.
Конечно, это не означает, что точные вычисления для таких чисел невозможны. Они возможны. И даже необходимы.
Например, есть два способа сложить 0.1 и 0.2:
Сделать их целыми, сложить, а потом поделить:
 	alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
Это работает, так как числа 0.1*10 = 1 и 0.2*10 = 2 могут быть точно представлены в двоичной системе.
Сложить, а затем округлить до разумного знака после запятой. Округления до 10-го знака обычно бывает достаточно, чтобы отсечь ошибку вычислений:
	 var result = 0.1 + 0.2;
	alert( +result.toFixed(10) ); // 0.3
		Забавный пример
Привет! Я – число, растущее само по себе!
 	alert( 9999999999999999 ); // выведет 10000000000000000
Причина та же – потеря точности.
Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит хранят позицию десятичной точки и один бит – знак. Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.
Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число», что мы и видим в примере выше. Как говорится: «как смог, так записал».
Ради справедливости заметим, что в точности то же самое происходит в любом другом языке, где используется формат IEEE 754, включая Java, C, PHP, Ruby, Perl.


Тригонометрия
Встроенные функции для тригонометрических вычислений:
Math.acos(x)
Возвращает арккосинус x (в радианах)
Math.asin(x)
Возвращает арксинус x (в радианах)
Math.atan(x)
Возвращает арктангенс x (в радианах)
Math.atan2(y, x)
Возвращает угол до точки (y, x). Описание функции: Atan2.
Math.sin(x)
Вычисляет синус x
Math.cos(x)
Вычисляет косинус x
Math.tan(x)
Возвращает тангенс x
Функции общего назначения
Разные полезные функции:
Math.sqrt(x)
Возвращает квадратный корень из x.
Math.log(x)
Возвращает натуральный (по основанию e) логарифм x.
Math.pow(x, exp)
Возводит число в степень, возвращает xexp, например Math.pow(2,3) = 8. Работает в том числе с дробными и отрицательными степенями, например: Math.pow(4, -1/2) = 0.5.
Math.abs(x)
Возвращает абсолютное значение числа
Math.exp(x)
Возвращает ex, где e – основание натуральных логарифмов.
Math.max(a, b, c...)
Возвращает наибольший из списка аргументов
Math.min(a, b, c...)
Возвращает наименьший из списка аргументов
Math.random()
Возвращает псевдослучайное число в интервале [0,1) – то есть между 0 (включительно) и 1 (не включая). Генератор случайных чисел инициализуется текущим временем.






















Строки
	Экранирование специальных символов
Если строка в одинарных кавычках, то внутренние одинарные кавычки внутри должны быть экранированы, то есть снабжены обратным слешем \', вот так:
	var str = 'I\'m a JavaScript programmer';
В двойных кавычках – экранируются внутренние двойные:
	 var str = "I'm a JavaScript \"programmer\" ";
	alert( str ); // I'm a JavaScript "programmer"
Экранирование служит исключительно для правильного восприятия строки JavaScript. В памяти строка будет содержать сам символ без '\'. Вы можете увидеть это, запустив пример выше.
Сам символ обратного слэша '\' является служебным, поэтому всегда экранируется, т.е пишется как \\:
	 var str = ' символ \\ ';
	alert( str ); // символ \
Заэкранировать можно любой символ. Если он не специальный, то ничего не произойдёт:
	 alert( "\a" ); // a
	// идентично alert(  "a"  );


	Длина length
Одно из самых частых действий со строкой – это получение ее длины:
		 var str = "My\n"; // 3 символа. Третий - перевод строки
		alert( str.length ); // 3
	Доступ к символам
Чтобы получить символ, используйте вызов charAt(позиция). Первый символ имеет позицию 0:
	 var str = "jQuery";
	alert( str.charAt(0) ); // "j"
В JavaScript нет отдельного типа «символ», так что charAt возвращает строку, состоящую из выбранного символа.
Также для доступа к символу можно использовать квадратные скобки:
	 var str = "Я - современный браузер!";
	alert( str[0] ); // "Я"
Разница между этим способом и charAt заключается в том, что если символа нет – charAt выдает пустую строку, а скобки – undefined:
	 alert( "".charAt(0) ); // пустая строка
	alert( "" [0] ); // undefined
Вообще же метод charAt существует по историческим причинам, ведь квадратные скобки – проще и короче.
	Вызов метода – всегда со скобками
Обратите внимание, str.length – это свойство строки, а str.charAt(pos) – метод, т.е. функция.
Обращение к методу всегда идет со скобками, а к свойству – без скобок.


	Изменения строк
Содержимое строки в JavaScript нельзя изменять. Нельзя взять символ посередине и заменить его. Как только строка создана – она такая навсегда.

Можно лишь создать целиком новую строку и присвоить в переменную вместо старой, например:
		 var str = "строка";
		str = str[3] + str[4] + str[5];
		alert( str ); // ока
	Смена регистра
Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний:
 	alert( "Интерфейс".toUpperCase() ); // ИНТЕРФЕЙС
Пример ниже получает первый символ и приводит его к нижнему регистру:
	alert( "Интерфейс" [0].toLowerCase() ); // 'и'



	Поиск подстроки
Для поиска подстроки есть метод indexOf(подстрока[, начальная_позиция]).
Он возвращает позицию, на которой находится подстрока или -1, если ничего не найдено. Например:
	var str = "Widget with id";
	alert( str.indexOf("Widget") ); // 0, т.к. "Widget" найден прямо в начале str
	alert( str.indexOf("id") ); // 1, т.к. "id" найден, начиная с позиции 1
	alert( str.indexOf("widget") ); // -1, не найдено, так как поиск учитывает регистр
Необязательный второй аргумент позволяет искать, начиная с указанной позиции. Например, первый раз "id" появляется на позиции 1. Чтобы найти его следующее появление – запустим поиск с позиции 2:
	var str = "Widget with id";
	alert(str.indexOf("id", 2)) // 12, поиск начат с позиции 2
Также существует аналогичный метод lastIndexOf, который ищет не с начала, а с конца строки.
	На заметку:
Для красивого вызова indexOf применяется побитовый оператор НЕ '~'.
Дело в том, что вызов ~n эквивалентен выражению -(n+1), например:
	alert( ~2 ); // -(2+1) = -3
	alert( ~1 ); // -(1+1) = -2
	alert( ~0 ); // -(0+1) = -1
	alert( ~-1 ); // -(-1+1) = 0
Как видно, ~n – ноль только в случае, когда n == -1.
То есть, проверка if ( ~str.indexOf(...) ) означает, что результат indexOf отличен от -1, т.е. совпадение есть.
Вот так:
	var str = "Widget";
	if (~str.indexOf("get")) {
	  alert( 'совпадение есть!' );
	}
Вообще, использовать возможности языка неочевидным образом не рекомендуется, поскольку ухудшает читаемость кода.
Однако, в данном случае, все в порядке. Просто запомните: '~' читается как «не минус один», а "if ~str.indexOf" читается как "если найдено".


	Поиск всех вхождений
Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Как только получаем очередную позицию – начинаем следующий поиск со следующей.
Пример такого цикла:
	 var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке
	var target = "Иа"; // цель поиска
	var pos = 0;
	while (true) {
	  var foundPos = str.indexOf(target, pos);
	  if (foundPos == -1) break;

	  alert( foundPos ); // нашли на этой позиции
	  pos = foundPos + 1; // продолжить поиск со следующей
	}
Такой цикл начинает поиск с позиции 0, затем найдя подстроку на позиции foundPos, следующий поиск продолжит с позиции pos = foundPos+1, и так далее, пока что-то находит.
Впрочем, тот же алгоритм можно записать и короче:
	var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке
	var target = "Иа"; // цель поиска
	var pos = -1;
	while ((pos = str.indexOf(target, pos + 1)) != -1) {
	  alert( pos );
	}



	Взятие подстроки: substring, substr, slice
В JavaScript существуют целых 3 (!) метода для взятия подстроки, с небольшими отличиями между ними.

substring(start [, end])
Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end.
     var str = "stringify";
	alert(str.substring(0,1)); // "s", символы с позиции 0 по 1 не включая 1.
Если аргумент end отсутствует, то идет до конца строки:
     var str = "stringify";
	alert(str.substring(2)); // ringify, символы с позиции 2 до конца
substr(start [, length])
Первый аргумент имеет такой же смысл, как и в substring, а второй содержит не конечную позицию, а количество символов.
    var str = "stringify";
	str = str.substr(2,4); // ring, со 2-й позиции 4 символа
	alert(str)
Если второго аргумента нет – подразумевается «до конца строки».
slice(start [, end])
Возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров – такой же как в substring.

	Отрицательные аргументы
Различие между substring и slice – в том, как они работают с отрицательными и выходящими за границу строки аргументами:

substring(start, end)
Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки:
 	alert( "testme".substring(-2) ); // "testme", -2 становится 0
Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end:
	 alert( "testme".substring(4, -1) ); // "test"
	// -1 становится 0 -> получили substring(4, 0)
	// 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"

slice
Отрицательные значения отсчитываются от конца строки:
	 alert( "testme".slice(-2) ); // "me", от 2 позиции с конца
	 alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.
Это гораздо более удобно, чем странная логика substring.
Отрицательное значение первого параметра поддерживается в substr во всех браузерах, кроме IE8-.
Если выбирать из этих трёх методов один, для использования в большинстве ситуаций – то это будет slice: он и отрицательные аргументы поддерживает и работает наиболее очевидно.



Кодировка Юникод
Как мы знаем, символы сравниваются в алфавитном порядке 'А' < 'Б' < 'В' < ... < 'Я'.
Но есть несколько странностей…
1 - Почему буква 'а' маленькая больше буквы 'Я' большой?
 	alert( 'а' > 'Я' ); // true
2 - Буква 'ё' находится в алфавите между е и ж: абвгдеёжз…. Но почему тогда 'ё' больше 'я'?
 	alert( 'ё' > 'я' ); // true
Чтобы разобраться с этим, обратимся к внутреннему представлению строк в JavaScript.

Все строки имеют внутреннюю кодировку Юникод.
Неважно, на каком языке написана страница, находится ли она в windows-1251 или utf-8. Внутри JavaScript-интерпретатора все строки приводятся к единому «юникодному» виду. Каждому символу соответствует свой код.
Есть метод для получения символа по его коду:
	String.fromCharCode(code)
Возвращает символ по коду code:
 	alert( String.fromCharCode(1072) ); // 'а'
…И метод для получения цифрового кода из символа:
	str.charCodeAt(pos)
Возвращает код символа на позиции pos. Отсчет позиции начинается с нуля.
 	alert( "абрикос".charCodeAt(0) ); // 1072, код 'а'
Теперь вернемся к примерам выше. Почему сравнения 'ё' > 'я' и 'а' > 'Я' дают такой странный результат?
Дело в том, что символы сравниваются не по алфавиту, а по коду. У кого код больше – тот и больше. В юникоде есть много разных символов. Кириллическим буквам соответствует только небольшая часть из них, подробнее – Кириллица в Юникоде.
Выведем отрезок символов юникода с кодами от 1034 до 1113:
	 var str = '';
	for (var i = 1034; i <= 1113; i++) {
	  str += String.fromCharCode(i);
	}
	alert( str );
Результат:
ЊЋЌЍЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюяѐёђѓєѕіїјљ
Мы можем увидеть из этого отрезка две важных вещи:
Строчные буквы идут после заглавных, поэтому они всегда больше.
В частности, 'а'(код 1072) > 'Я'(код 1071).
То же самое происходит и в английском алфавите, там 'a' > 'Z'.
Ряд букв, например ё, находятся вне основного алфавита.
В частности, маленькая буква ё имеет код, больший чем я, поэтому 'ё'(код 1105) > 'я'(код 1103).
Кстати, большая буква Ё располагается в Unicode до А, поэтому 'Ё'(код 1025) < 'А'(код 1040). Удивительно: есть буква меньше чем А :)
Буква ё не уникальна, точки над буквой используются и в других языках, приводя к тому же результату.
Например, при работе с немецкими названиями:
 alert( "ö" > "z" ); // true
	Юникод в HTML
Кстати, если мы знаем код символа в кодировке юникод, то можем добавить его в HTML, используя «числовую ссылку» (numeric character reference).
Для этого нужно написать сначала &#, затем код, и завершить точкой с запятой ';'. Например, символ 'а' в виде числовой ссылки: &#1072;.
Если код хотят дать в 16-ричной системе счисления, то начинают с &#x.
В юникоде есть много забавных и полезных символов, например, символ ножниц: ✂ (&#x2702;), дроби: ½ (&#xBD;) ¾ (&#xBE;) и другие. Их можно использовать вместо картинок в дизайне.



	Посимвольное сравнение
Сравнение строк работает лексикографически, иначе говоря, посимвольно.
Сравнение строк s1 и s2 обрабатывается по следующему алгоритму:
Сравниваются первые символы: s1[0] и s2[0]. Если они разные, то сравниваем их и, в зависимости от результата их сравнения, возвратить true или false. Если же они одинаковые, то…
Сравниваются вторые символы s1[1] и s2[1]
Затем третьи s1[2] и s2[2] и так далее, пока символы не будут наконец разными, и тогда какой символ больше – та строка и больше. Если же в какой-либо строке закончились символы, то считаем, что она меньше, а если закончились в обеих – они равны.
Спецификация языка определяет этот алгоритм более детально. Если же говорить простыми словами, смысл алгоритма в точности соответствует порядку, по которому имена заносятся в орфографический словарь.
	"Вася" > "Ваня" // true, т.к. начальные символы совпадают, а потом 'с' > 'н'
	"Дома" > "До" // true, т.к. начало совпадает, но в 1-й строке больше символов
Числа в виде строк сравниваются как строки
Бывает, что числа приходят в скрипт в виде строк, например как результат prompt. В этом случае результат их сравнения будет неверным:
	 alert( "2" > "14" ); // true, так как это строки, и для первых символов верно "2" > "1"
Если хотя бы один аргумент – не строка, то другой будет преобразован к числу:
	 alert( 2 > "14" ); // false


	 Правильное сравнение
Все современные браузеры, кроме IE10- (для которых нужно подключить библиотеку Intl.JS) поддерживают стандарт ECMA 402, поддерживающий сравнение строк на разных языках, с учётом их правил.
Способ использования:
	 var str = "Ёлки";
	alert( str.localeCompare("Яблони") ); // -1
Метод str1.localeCompare(str2) возвращает -1, если str1 < str2, 1, если str1 > str2 и 0, если они равны.
Более подробно про устройство этого метода можно будет узнать в статье Intl: интернационализация в JavaScript, когда это вам понадобится.

